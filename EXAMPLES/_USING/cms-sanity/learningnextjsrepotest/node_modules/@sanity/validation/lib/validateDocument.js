"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var Type = require('type-of-is');

var _require = require('lodash'),
    flatten = _require.flatten;

var ValidationError = require('./ValidationError');
/* eslint-disable no-console */


module.exports = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (doc, schema) {
    var documentType = schema.get(doc._type);

    if (!documentType) {
      console.warn('Schema type for object type "%s" not found, skipping validation', doc._type);
      return [];
    }

    try {
      return yield validateItem(doc, documentType, [], {
        document: doc
      });
    } catch (err) {
      console.error(err);
      return [{
        type: 'validation',
        level: 'error',
        path: [],
        item: new ValidationError(err.message)
      }];
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function validateItem(item, type, path, options) {
  if (Array.isArray(item)) {
    return validateArray(item, type, path, options);
  }

  if (typeof item === 'object') {
    return validateObject(item, type, path, options);
  }

  return validatePrimitive(item, type, path, options);
}

module.exports.validateItem = validateItem;

function validateObject(obj, type, path, options) {
  if (!type) {
    return [];
  } // Validate actual object itself


  var objChecks = [];

  if (type.validation) {
    objChecks = type.validation.map( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (rule) {
        var ruleResults = yield rule.validate(obj, {
          parent: options.parent,
          document: options.document,
          path,
          type
        });
        return applyPath(ruleResults, path);
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    }());
  } // Validate fields within object


  var fields = type.fields || [];
  var fieldChecks = fields.map(field => {
    var validation = field.type && field.type.validation;

    if (!validation) {
      return [];
    }

    var fieldPath = appendPath(path, field.name);
    var fieldValue = obj[field.name];
    return validateItem(fieldValue, field.type, fieldPath, {
      parent: obj,
      document: options.document,
      path: fieldPath,
      type: field.type
    });
  });
  return Promise.all([...objChecks, ...fieldChecks]).then(flatten);
}

function validateArray(items, type, path, options) {
  if (!type) {
    return [{
      type: 'validation',
      level: 'error',
      path,
      item: new ValidationError('Unable to resolve type for array')
    }];
  } // Validate actual array itself


  var arrayChecks = [];

  if (type.validation) {
    arrayChecks = type.validation.map( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (rule) {
        var ruleResults = yield rule.validate(items, {
          parent: options.parent,
          document: options.document,
          path,
          type
        });
        return applyPath(ruleResults, path);
      });

      return function (_x4) {
        return _ref3.apply(this, arguments);
      };
    }());
  } // Validate items within array


  var itemChecks = items.map((item, i) => {
    var pathSegment = item && item._key ? {
      _key: item._key
    } : i;
    var itemType = resolveTypeForArrayItem(item, type.of);
    var itemPath = appendPath(path, [pathSegment]);
    return validateItem(item, itemType, itemPath, {
      parent: items,
      document: options.document,
      path: itemPath
    });
  });
  return Promise.all([...arrayChecks, ...itemChecks]).then(flatten);
}

function validatePrimitive(item, type, path, options) {
  if (!type) {
    return [{
      type: 'validation',
      level: 'error',
      path,
      item: new ValidationError('Unable to resolve type for item')
    }];
  }

  if (!type.validation) {
    return [];
  }

  var results = type.validation.map(rule => {
    var _options$type, _options$type2;

    return rule.validate(item, {
      parent: options.parent,
      document: options.document,
      path,
      type: {
        name: (_options$type = options.type) === null || _options$type === void 0 ? void 0 : _options$type.name,
        options: (_options$type2 = options.type) === null || _options$type2 === void 0 ? void 0 : _options$type2.options
      }
    }).then(currRuleResults => applyPath(currRuleResults, path));
  });
  return Promise.all(results).then(flatten);
}

function resolveTypeForArrayItem(item, candidates) {
  var primitive = typeof item === 'undefined' || item === null || !item._type && Type.string(item).toLowerCase();

  if (primitive && primitive !== 'object') {
    return candidates.find(candidate => candidate.jsonType === primitive);
  }

  return candidates.find(candidate => candidate.type.name === item._type) || candidates.find(candidate => candidate.name === item._type) || candidates.find(candidate => candidate.name === 'object' && primitive === 'object');
}

function appendPath(base, next) {
  return base.concat(next);
}

function applyPath(results, pathPrefix) {
  return results.map(result => {
    var path = typeof result.path === 'undefined' ? pathPrefix : pathPrefix.concat(result.path);
    return _objectSpread(_objectSpread({
      type: 'validation'
    }, result), {}, {
      path
    });
  });
}