"use strict";

var _format = _interopRequireDefault(require("date-fns/format"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ValidationError = require('../ValidationError');

var genericValidator = require('./genericValidator');

var isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;

var getFormattedDate = function getFormattedDate() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var value = arguments.length > 1 ? arguments[1] : undefined;
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var format = 'yyyy-MM-dd';

  if (options && options.dateFormat) {
    format = options.dateFormat;
  }

  if (type === 'date') {
    // If the type is date only
    return (0, _format.default)(value, format);
  } // If the type is datetime


  if (options && options.timeFormat) {
    format += " ".concat(options.timeFormat);
  } else {
    format += ' HH:mm';
  }

  return (0, _format.default)(value, format);
};

var type = (unused, value, message) => {
  var strVal = "".concat(value);

  if (!strVal || isoDate.test(value)) {
    return true;
  }

  return new ValidationError(message || 'Must be a valid ISO-8601 formatted date string');
};

var min = (minDate, value, message, field) => {
  var dateVal = value && parseDate(value);

  if (!dateVal) {
    return true; // `type()` should catch parse errors
  }

  if (!value || dateVal >= parseDate(minDate, true)) {
    return true;
  }

  var date = getFormattedDate(field.type.name, minDate, field.type.options);
  return new ValidationError(message || "Must be at or after ".concat(date));
};

var max = (maxDate, value, message, field) => {
  var dateVal = value && parseDate(value);

  if (!dateVal) {
    return true; // `type()` should catch parse errors
  }

  if (!value || dateVal <= parseDate(maxDate, true)) {
    return true;
  }

  var date = getFormattedDate(field.type.name, maxDate, field.type.options);
  return new ValidationError(message || "Must be at or before ".concat(date));
};

function parseDate(date, throwOnError) {
  if (date === 'now') {
    return new Date();
  }

  var parsed = new Date(date);
  var isInvalid = isNaN(parsed.getTime());

  if (isInvalid && throwOnError) {
    throw new Error("Unable to parse \"".concat(date, "\" to a date"));
  }

  return isInvalid ? null : parsed;
}

module.exports = Object.assign({}, genericValidator, {
  type,
  min,
  max
});