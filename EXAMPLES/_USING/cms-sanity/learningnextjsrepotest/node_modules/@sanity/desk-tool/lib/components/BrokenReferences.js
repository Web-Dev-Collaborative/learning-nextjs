"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactPropsStream = require("react-props-stream");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _default2 = _interopRequireDefault(require("part:@sanity/components/panes/default"));

var _preview = require("part:@sanity/base/preview");

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _formBuilder = _interopRequireDefault(require("part:@sanity/form-builder"));

var _panePopover = _interopRequireDefault(require("part:@sanity/components/dialogs/pane-popover"));

var _BrokenReferences = _interopRequireDefault(require("./BrokenReferences.css"));

var _ReferringDocumentsList = _interopRequireDefault(require("./ReferringDocumentsList"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function BrokenRefs(props) {
  var documents = props.documents,
      type = props.type,
      schema = props.schema;
  var schemaType = schema.get(type);

  var _documents$reduce = documents.reduce((groups, doc) => {
    var group = doc.hasDraft ? groups.unpublished : groups.nonExistent;
    group.push(doc);
    return groups;
  }, {
    unpublished: [],
    nonExistent: []
  }),
      unpublished = _documents$reduce.unpublished,
      nonExistent = _documents$reduce.nonExistent;

  var renderNonExisting = nonExistent.length > 0;
  var renderUnpublished = !renderNonExisting;
  return /*#__PURE__*/_react.default.createElement(_default2.default, {
    title: "New ".concat(type),
    isScrollable: false
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: _BrokenReferences.default.brokenReferences
  }, renderNonExisting && /*#__PURE__*/_react.default.createElement(_panePopover.default, {
    icon: true,
    kind: "error",
    id: "missing-references",
    title: "Missing references",
    subtitle: "The new document can only reference existing documents. ".concat(nonExistent.length === 1 ? 'A document' : 'Documents', " with the following ID").concat(nonExistent.length === 1 ? ' was' : 's were', " not found:")
  }, /*#__PURE__*/_react.default.createElement("ul", {
    className: _BrokenReferences.default.tagList
  }, nonExistent.map(doc => /*#__PURE__*/_react.default.createElement("li", {
    className: _BrokenReferences.default.tagItem,
    key: doc.id
  }, doc.id)))), renderUnpublished && /*#__PURE__*/_react.default.createElement(_panePopover.default, {
    icon: true,
    kind: "warning",
    id: "unpublished-documents",
    title: "Unpublished references",
    subtitle: "A document can only refer to published documents. Publish the following ".concat(unpublished.length === 1 ? 'draft' : 'drafts', " before creating\n            a new document.")
  }, /*#__PURE__*/_react.default.createElement(_ReferringDocumentsList.default, {
    documents: unpublished.map(_ref => {
      var id = _ref.id,
          type = _ref.type,
          hasDraft = _ref.hasDraft;
      return {
        _id: "drafts.".concat(id),
        _type: type,
        _hasDraft: hasDraft
      };
    })
  }))), /*#__PURE__*/_react.default.createElement("form", {
    className: _BrokenReferences.default.editor
  }, /*#__PURE__*/_react.default.createElement(_formBuilder.default, {
    readOnly: true,
    type: schemaType,
    schema: schema
  })));
}

BrokenRefs.propTypes = {
  schema: _propTypes.default.any,
  type: _propTypes.default.any,
  document: _propTypes.default.any,
  documents: _propTypes.default.arrayOf(_propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    hasDraft: _propTypes.default.bool.isRequired
  }))
}; // @todo consider adding a progress indicator instead?

var BrokenReferences = (0, _reactPropsStream.streamingComponent)(props$ => props$.pipe((0, _operators.switchMap)(props => {
  var ids = findReferences(props.document);
  var type = props.type,
      schema = props.schema;

  if (!ids.length) {
    return (0, _rxjs.of)(props.children);
  }

  return (0, _rxjs.from)(ids).pipe((0, _operators.mergeMap)(checkExistance), (0, _operators.scan)((prev, curr) => (0, _uniqBy2.default)([curr, ...prev], 'id'), []), (0, _operators.filter)(docs => docs.length === ids.length), (0, _operators.map)(docs => docs.filter(isMissingPublished)), (0, _operators.map)(broken => broken.length > 0 ? /*#__PURE__*/_react.default.createElement(BrokenRefs, {
    documents: broken,
    type: type,
    schema: schema
  }) : props.children));
})));

function checkExistance(id) {
  return (0, _rxjs.merge)((0, _preview.observePaths)((0, _draftUtils.getDraftId)(id), ['_type']).pipe((0, _operators.map)(draft => ({
    draft
  }))), (0, _preview.observePaths)((0, _draftUtils.getPublishedId)(id), ['_type']).pipe((0, _operators.map)(published => ({
    published
  })))).pipe((0, _operators.scan)((prev, res) => _objectSpread(_objectSpread({}, prev), res), {}), (0, _operators.filter)(res => 'draft' in res && 'published' in res), (0, _operators.map)(res => ({
    id,
    type: getDocumentType(res),
    hasDraft: Boolean(res.draft),
    hasPublished: Boolean(res.published)
  })));
}

function getDocumentType(_ref2) {
  var draft = _ref2.draft,
      published = _ref2.published;

  if (draft || published) {
    return draft ? draft._type : published._type;
  }

  return undefined;
}

function isMissingPublished(doc) {
  return !doc.hasPublished;
}

function findReferences(value) {
  return dedupeReferences(extractStrongReferences(value));
}

function extractStrongReferences(value) {
  if (Array.isArray(value)) {
    return value.reduce((refs, item) => [...refs, ...extractStrongReferences(item)], []);
  }

  if (typeof value === 'object' && value !== null) {
    return Object.keys(value).reduce((refs, key) => key === '_ref' && !value._weak ? [...refs, value[key]] : [...refs, ...extractStrongReferences(value[key])], []);
  }

  return [];
}

function dedupeReferences(refs) {
  return (0, _uniq2.default)(refs.map(ref => (ref || '').replace(/^drafts\./, '')));
}

var _default = BrokenReferences;
exports.default = _default;