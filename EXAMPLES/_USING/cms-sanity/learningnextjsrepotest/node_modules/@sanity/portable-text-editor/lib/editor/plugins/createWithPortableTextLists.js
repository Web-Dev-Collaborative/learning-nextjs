"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithPortableTextLists = void 0;
const slate_1 = require("slate");
const debug_1 = require("../../utils/debug");
const selection_1 = require("../../utils/selection");
const debug = debug_1.debugWithName('plugin:withPortableTextLists');
const MAX_LIST_LEVEL = 10;
function createWithPortableTextLists(portableTextFeatures, change$) {
    return function withPortableTextLists(editor) {
        // // Extend Slate's default normalization to set / unset level on .listItem blocks.
        // const {normalizeNode} = editor
        // editor.normalizeNode = nodeEntry => {
        //   normalizeNode(nodeEntry)
        //   const operations = editor.operations.map(op => {
        //     if (op.type === 'set_node' && op.newProperties && op.newProperties.listItem) {
        //       // debug('Normalizing level for list item')
        //       op.newProperties.level = op.newProperties.level || 1
        //     } else if (op.newProperties && op.newProperties.level) {
        //       // TODO: will level be used otherwise? Text indentation?
        //       // debug('Deleting obsolete level prop from non list item')
        //       delete op.newProperties.level
        //     }
        //     return op
        //   })
        //   editor.operations = operations
        // }
        editor.pteToggleListItem = (listItemStyle) => {
            const isActive = editor.pteHasListStyle(listItemStyle);
            if (isActive) {
                debug(`Remove list item '${listItemStyle}'`);
                editor.pteUnsetListItem(listItemStyle);
            }
            else {
                debug(`Add list item '${listItemStyle}'`);
                editor.pteSetListItem(listItemStyle);
            }
            const newSelection = selection_1.toPortableTextRange(editor);
            if (newSelection !== undefined) {
                // Emit a new selection here (though it might be the same).
                // This is for toolbars etc that listens to selection changes to update themselves.
                change$.next({ type: 'selection', selection: newSelection });
            }
        };
        editor.pteUnsetListItem = (listItemStyle) => {
            if (!editor.selection) {
                return;
            }
            const selectedBlocks = [
                ...slate_1.Editor.nodes(editor, {
                    at: editor.selection,
                    match: node => slate_1.Element.isElement(node) && node._type === portableTextFeatures.types.block.name
                })
            ];
            selectedBlocks.forEach(([node, path]) => {
                const { listItem, level } = node, rest = __rest(node, ["listItem", "level"]);
                debug(`Unsetting list '${listItemStyle}'`);
                slate_1.Transforms.setNodes(editor, Object.assign(Object.assign({}, rest), { listItem: undefined, level: undefined }), { at: path });
            });
            // Emit a new selection here (though it might be the same).
            // This is for toolbars etc that listens to selection changes to update themselves.
            change$.next({ type: 'selection', selection: selection_1.toPortableTextRange(editor) });
            editor.onChange();
        };
        editor.pteSetListItem = (listItemStyle) => {
            if (!editor.selection) {
                return;
            }
            const selectedBlocks = [
                ...slate_1.Editor.nodes(editor, {
                    at: editor.selection,
                    match: node => slate_1.Element.isElement(node) && node._type === portableTextFeatures.types.block.name
                })
            ];
            selectedBlocks.forEach(([node, path]) => {
                const { listItem, level } = node, rest = __rest(node, ["listItem", "level"]);
                debug(`Setting list '${listItemStyle}'`);
                slate_1.Transforms.setNodes(editor, Object.assign(Object.assign({}, rest), { level: 1, listItem: listItemStyle ||
                        (portableTextFeatures.lists[0] && portableTextFeatures.lists[0].value) }), { at: path });
            });
            // Emit a new selection here (though it might be the same).
            // This is for toolbars etc that listens to selection changes to update themselves.
            change$.next({ type: 'selection', selection: selection_1.toPortableTextRange(editor) });
            editor.onChange();
        };
        editor.pteEndList = () => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...slate_1.Editor.nodes(editor, {
                    at: editor.selection,
                    match: node => slate_1.Element.isElement(node) &&
                        node._type === portableTextFeatures.types.block.name &&
                        node.listItem &&
                        node.children.length === 1 &&
                        node.children[0].text === ''
                })
            ];
            if (selectedBlocks.length === 0) {
                return false;
            }
            selectedBlocks.forEach(([node, path]) => {
                debug('Unset list');
                slate_1.Transforms.setNodes(editor, Object.assign(Object.assign({}, node), { level: undefined, listItem: undefined }), { at: path });
            });
            change$.next({ type: 'selection', selection: selection_1.toPortableTextRange(editor) });
            return true; // Note: we are exiting the plugin chain by not returning editor (or hotkey plugin 'enter' will fire)
        };
        editor.pteIncrementBlockLevels = (reverse) => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...slate_1.Editor.nodes(editor, {
                    at: editor.selection,
                    match: node => !!(slate_1.Element.isElement(node) && node.listItem)
                })
            ];
            if (selectedBlocks.length === 0) {
                return false;
            }
            selectedBlocks.forEach(([node, path]) => {
                let level = typeof node.level === 'number' ? node.level : 1;
                if (reverse) {
                    level--;
                    debug('Decrementing list level', Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
                }
                else {
                    level++;
                    debug('Incrementing list level', Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
                }
                slate_1.Transforms.setNodes(editor, { level: Math.min(MAX_LIST_LEVEL, Math.max(1, level)) }, { at: path });
            });
            change$.next({ type: 'selection', selection: selection_1.toPortableTextRange(editor) });
            editor.onChange();
            return true;
        };
        editor.pteHasListStyle = (listStyle) => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...slate_1.Editor.nodes(editor, {
                    at: editor.selection,
                    match: node => slate_1.Element.isElement(node) && node.listItem === listStyle
                })
            ];
            if (selectedBlocks.length > 0) {
                return true;
            }
            return false;
        };
        return editor;
    };
}
exports.createWithPortableTextLists = createWithPortableTextLists;
//# sourceMappingURL=createWithPortableTextLists.js.map