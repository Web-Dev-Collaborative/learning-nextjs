"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DraggableBlock = void 0;
const react_1 = __importStar(require("react"));
const slate_1 = require("slate");
const slate_react_1 = require("@sanity/slate-react");
const debug_1 = require("../utils/debug");
const weakMaps_1 = require("../utils/weakMaps");
const nodes_1 = require("./nodes");
const debug = debug_1.debugWithName('components:DraggableBlock');
const debugRenders = false;
function useForceUpdate() {
    const [, setValue] = react_1.useState(0);
    return () => setValue(value => ++value);
}
exports.DraggableBlock = ({ children, element, readOnly }) => {
    const editor = slate_react_1.useEditor();
    const dragGhostRef = react_1.useRef();
    const forceUpdate = useForceUpdate();
    const [isDragOver, setIsDragOver] = react_1.useState(false);
    const isVoid = react_1.useMemo(() => slate_1.Editor.isVoid(editor, element), []);
    const isInline = react_1.useMemo(() => slate_1.Editor.isInline(editor, element), []);
    if (readOnly) {
        return react_1.default.createElement(react_1.default.Fragment, null, children);
    }
    debugRenders && debug('render');
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    const handleDragOver = event => {
        const isMyDragOver = weakMaps_1.IS_DRAGGING_BLOCK_ELEMENT.get(editor);
        // debug('Drag over', isMyDragOver)
        if (!isMyDragOver) {
            return;
        }
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
        weakMaps_1.IS_DRAGGING_ELEMENT_TARGET.set(editor, element);
        const blockElement = slate_react_1.ReactEditor.toDOMNode(editor, element);
        const elementRect = blockElement.getBoundingClientRect();
        const offset = elementRect.top;
        const height = elementRect.height;
        var Y = event.pageY;
        var loc = Math.abs(offset - Y);
        let position;
        if (element === editor.children[0]) {
            position = 'top';
        }
        else if (loc < height / 2) {
            position = 'top';
            weakMaps_1.IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        else {
            position = 'bottom';
            weakMaps_1.IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        if (isMyDragOver === element) {
            event.dataTransfer.dropEffect = 'none';
            return;
        }
        forceUpdate();
        setIsDragOver(true);
    };
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    const handleDragLeave = event => {
        setIsDragOver(false);
    };
    // Note: this is called for the dragging block
    const handleDragEnd = event => {
        weakMaps_1.IS_DRAGGING.set(editor, false);
        event.preventDefault();
        event.stopPropagation();
        const targetBlock = weakMaps_1.IS_DRAGGING_ELEMENT_TARGET.get(editor);
        weakMaps_1.IS_DRAGGING_ELEMENT_TARGET.delete(editor);
        if (dragGhostRef.current) {
            debug('Removing drag ghost');
            document.body.removeChild(dragGhostRef.current);
        }
        if (targetBlock) {
            const dragPosition = weakMaps_1.IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
            weakMaps_1.IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
            let targetPath = slate_react_1.ReactEditor.findPath(editor, targetBlock);
            const myPath = slate_react_1.ReactEditor.findPath(editor, element);
            const isBefore = slate_1.Path.isBefore(myPath, targetPath);
            if (dragPosition === 'bottom' && !isBefore) {
                // If it is already at the bottom, don't do anything.
                if (targetPath[0] >= editor.children.length - 1) {
                    debug('target is already at the bottom, not moving');
                    return;
                }
                const originalPath = targetPath;
                targetPath = slate_1.Path.next(targetPath);
                debug(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);
            }
            if (dragPosition === 'top' && isBefore && targetPath[0] !== editor.children.length - 1) {
                const originalPath = targetPath;
                targetPath = slate_1.Path.previous(targetPath);
                debug(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);
            }
            if (slate_1.Path.equals(targetPath, myPath)) {
                event.preventDefault();
                debug('targetPath and myPath is the same, not moving');
                return;
            }
            debug(`Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`);
            slate_1.Transforms.moveNodes(editor, { at: myPath, to: targetPath });
            editor.onChange();
            return;
        }
        debug('No target element, not doing anything');
    };
    // Note: this is called not for the dragging block, but for the drop target
    const handleDrop = event => {
        if (weakMaps_1.IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {
            debug('On drop (prevented)', element);
            event.preventDefault();
            event.stopPropagation();
            setIsDragOver(false);
        }
    };
    // Note: this is called for the dragging block
    const handleDrag = event => {
        if (!isVoid) {
            weakMaps_1.IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            return;
        }
        weakMaps_1.IS_DRAGGING.set(editor, true);
        weakMaps_1.IS_DRAGGING_BLOCK_ELEMENT.set(editor, element);
        event.stopPropagation(); // Stop propagation so that leafs don't get this and take focus/selection!
    };
    // Note: this is called for the dragging block
    const handleDragStart = event => {
        if (!isVoid || isInline) {
            debug('Not dragging block');
            weakMaps_1.IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            weakMaps_1.IS_DRAGGING.set(editor, false);
            return;
        }
        debug('Drag start');
        weakMaps_1.IS_DRAGGING.set(editor, true);
        event.dataTransfer.setData('application/portable-text', 'something');
        event.dataTransfer.effectAllowed = 'move none';
        // Specify dragImage so that single elements in the preview will not be the drag image,
        // but always the whole block preview itself.
        // Also clone it so that it will not be visually clipped by scroll-containers etc.
        const element = event.currentTarget;
        if (element && element instanceof HTMLElement) {
            const dragGhost = element.cloneNode(true);
            dragGhostRef.current = dragGhost;
            dragGhost.style.width = `${element.clientWidth}px`;
            dragGhost.style.height = `${element.clientHeight}px`;
            dragGhost.style.position = 'absolute';
            dragGhost.style.top = '-99999px';
            dragGhost.style.left = '-99999px';
            if (document.body) {
                document.body.appendChild(dragGhost);
                const rect = element.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                dragGhost.style.width = `${rect.width}px`;
                dragGhost.style.height = `${rect.height}px`;
                event.dataTransfer.setDragImage(dragGhost, x, y);
            }
        }
        handleDrag(event);
    };
    const isDraggingOverFirstBlock = isDragOver && editor.children[0] === weakMaps_1.IS_DRAGGING_ELEMENT_TARGET.get(editor);
    const isDraggingOverLastBlock = isDragOver &&
        editor.children[editor.children.length - 1] === weakMaps_1.IS_DRAGGING_ELEMENT_TARGET.get(editor);
    const dragPosition = weakMaps_1.IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
    return (react_1.default.createElement("div", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop },
        react_1.default.createElement(nodes_1.DraggableBlockWrappper, { isDraggingOverTop: isDraggingOverFirstBlock ||
                (isDragOver &&
                    !isDraggingOverFirstBlock &&
                    !isDraggingOverLastBlock &&
                    dragPosition === 'top'), isDraggingOverBottom: isDraggingOverLastBlock ||
                (isDragOver &&
                    !isDraggingOverFirstBlock &&
                    !isDraggingOverLastBlock &&
                    dragPosition === 'bottom') }, children)));
};
//# sourceMappingURL=DraggableBlock.js.map