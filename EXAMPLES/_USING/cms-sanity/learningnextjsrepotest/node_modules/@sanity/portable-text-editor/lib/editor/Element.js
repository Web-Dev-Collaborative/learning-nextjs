"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Element = void 0;
const react_1 = __importStar(require("react"));
const slate_1 = require("slate");
const slate_react_1 = require("@sanity/slate-react");
const TextBlock_1 = __importDefault(require("./nodes/TextBlock"));
const DefaultObject_1 = __importDefault(require("./nodes/DefaultObject"));
const index_1 = require("./nodes/index");
const values_1 = require("../utils/values");
const debug_1 = require("../utils/debug");
const DraggableBlock_1 = require("./DraggableBlock");
const DraggableChild_1 = require("./DraggableChild");
const nodes_1 = require("./nodes");
const weakMaps_1 = require("../utils/weakMaps");
const debug = debug_1.debugWithName('components:Element');
const debugRenders = false;
const defaultRender = value => {
    return react_1.default.createElement(DefaultObject_1.default, { value: value });
};
exports.Element = ({ attributes, children, element, keyGenerator, portableTextFeatures, readOnly, renderBlock, renderChild }) => {
    const editor = slate_react_1.useEditor();
    const selected = slate_react_1.useSelected();
    const blockObjectRef = react_1.useRef(null);
    const inlineBlockObjectRef = react_1.useRef(null);
    const focused = (selected && editor.selection && slate_1.Range.isCollapsed(editor.selection)) || false;
    if (typeof element._type !== 'string') {
        throw new Error(`Expected element to have a _type property`);
    }
    if (typeof element._key !== 'string') {
        throw new Error(`Expected element to have a _key property`);
    }
    // Test for inline objects first
    if (editor.isInline(element)) {
        const path = slate_react_1.ReactEditor.findPath(editor, element);
        const [block] = slate_1.Editor.node(editor, path, { depth: 1 });
        const type = portableTextFeatures.types.inlineObjects.find(type => type.name === element._type);
        if (!type) {
            throw new Error('Could not find type for inline block element');
        }
        if (block && typeof element._key === 'string' && typeof block._key === 'string') {
            const path = [{ _key: block._key }, 'children', { _key: element._key }];
            debugRenders && debug(`Render ${element._key} (inline object)`);
            const inlineBlockStyle = { display: 'inline-block' };
            return (react_1.default.createElement("span", Object.assign({}, attributes, { style: inlineBlockStyle }),
                react_1.default.createElement(DraggableChild_1.DraggableChild, { element: element, readOnly: readOnly, spanType: portableTextFeatures.types.span.name, keyGenerator: keyGenerator },
                    react_1.default.createElement("span", { ref: inlineBlockObjectRef, key: element._key, style: inlineBlockStyle, contentEditable: false },
                        renderChild &&
                            renderChild(values_1.fromSlateValue([element], portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0], type, { focused, selected, path }, defaultRender, inlineBlockObjectRef),
                        !renderChild &&
                            defaultRender(values_1.fromSlateValue([element], portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0]),
                        children))));
        }
        else {
            throw new Error('Block not found!');
        }
    }
    let className = '';
    // If not inline, it's either a block (text) or a block object (non-text)
    // NOTE: text blocks aren't draggable with DraggableBlock (yet?)
    switch (element._type) {
        case portableTextFeatures.types.block.name:
            debugRenders && debug(`Render ${element._key} (text block)`);
            const textBlock = (react_1.default.createElement(TextBlock_1.default, { element: element, portableTextFeatures: portableTextFeatures, readOnly: readOnly }, children));
            const renderedBlock = renderBlock &&
                renderBlock(values_1.fromSlateValue([element], element._type, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0], portableTextFeatures.types.block, {
                    focused,
                    selected,
                    path: [{ _key: element._key }]
                }, () => textBlock, blockObjectRef);
            className = `pt-block pt-text-block pt-text-block-style-${element.style}`;
            if (element.listItem) {
                className += ` pt-list-item pt-list-item-${element.listItem}`;
            }
            return (react_1.default.createElement(react_1.default.Fragment, null,
                renderBlock && !element.listItem && (react_1.default.createElement("div", Object.assign({ ref: blockObjectRef }, attributes, { className: className, key: element._key }), renderedBlock)),
                renderBlock && element.listItem && (react_1.default.createElement(nodes_1.ListItem, Object.assign({ ref: blockObjectRef, className: className, listStyle: element.listItem, listLevel: element.level }, attributes, { key: element._key }),
                    react_1.default.createElement(nodes_1.ListItemInner, { className: "pt-list-item-inner" }, renderedBlock))),
                !renderBlock && (react_1.default.createElement("div", Object.assign({}, attributes, { className: className }), textBlock))));
        default:
            const type = portableTextFeatures.types.blockObjects.find(type => type.name === element._type);
            if (!type) {
                throw new Error(`Could not find schema type for block element of _type ${element._type}`);
            }
            className = 'pt-block pt-object-block';
            debugRenders && debug(`Render ${element._key} (object block)`);
            const block = values_1.fromSlateValue([element], portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0];
            const renderedBlockFromProps = renderBlock &&
                react_1.useMemo(() => {
                    return renderBlock(block, type, {
                        focused,
                        selected,
                        path: [{ _key: block._key }]
                    }, defaultRender, blockObjectRef);
                }, [block, focused, selected]);
            return (react_1.default.createElement("div", Object.assign({}, attributes, { className: className, key: element._key }),
                react_1.default.createElement(DraggableBlock_1.DraggableBlock, { element: element, readOnly: readOnly },
                    react_1.default.createElement(react_1.default.Fragment, null,
                        renderedBlockFromProps && (react_1.default.createElement("div", { ref: blockObjectRef, contentEditable: false }, renderedBlockFromProps)),
                        !renderBlock && (react_1.default.createElement(index_1.BlockObject, { selected: selected, className: className }, defaultRender(values_1.fromSlateValue([element], portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0]))),
                        children))));
    }
};
//# sourceMappingURL=Element.js.map