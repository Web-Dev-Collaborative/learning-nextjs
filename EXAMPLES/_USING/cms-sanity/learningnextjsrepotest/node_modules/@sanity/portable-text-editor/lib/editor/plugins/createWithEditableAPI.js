"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithEditableAPI = void 0;
const slate_1 = require("slate");
const lodash_1 = require("lodash");
const slate_react_1 = require("@sanity/slate-react");
const values_1 = require("../../utils/values");
const selection_1 = require("../../utils/selection");
const debug_1 = require("../../utils/debug");
const weakMaps_1 = require("../../utils/weakMaps");
const debug = debug_1.debugWithName('API:editable');
function createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator) {
    return function withEditableAPI(editor) {
        const { apply } = editor;
        // Convert the selection when the operation happens,
        // or we may be out of sync between selection and value
        editor.apply = (operation) => {
            apply(operation);
        };
        portableTextEditor.setEditable({
            focus: () => {
                slate_react_1.ReactEditor.focus(editor);
            },
            blur: () => {
                slate_react_1.ReactEditor.blur(editor);
            },
            toggleMark: (mark) => {
                editor.pteToggleMark(mark);
                slate_react_1.ReactEditor.focus(editor);
            },
            toggleList: (listStyle) => {
                editor.pteToggleListItem(listStyle);
                slate_react_1.ReactEditor.focus(editor);
            },
            toggleBlockStyle: (blockStyle) => {
                editor.pteToggleBlockStyle(blockStyle);
                slate_react_1.ReactEditor.focus(editor);
            },
            isMarkActive: (mark) => {
                // Try/catch this, as Slate may error because the selection is currently wrong
                // TODO: catch only relevant error from Slate
                try {
                    return editor.pteIsMarkActive(mark);
                }
                catch (err) {
                    return false;
                }
            },
            marks: () => {
                return (Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || []);
            },
            undo: () => editor.undo(),
            redo: () => editor.redo(),
            select: (selection) => {
                const isEmpty = values_1.isEqualToEmptyEditor(editor.children, portableTextFeatures); // TODO: check up on this
                if (isEmpty || selection === null) {
                    debug('No value or selection is null, deselecting');
                    slate_1.Transforms.deselect(editor);
                    return;
                }
                const slateSelection = selection_1.toSlateRange(selection, editor);
                if (slateSelection) {
                    const [node] = slate_1.Editor.node(editor, slateSelection);
                    if (slate_1.Editor.isVoid(editor, node)) {
                        slate_1.Transforms.select(editor, slateSelection.focus.path.concat(0));
                    }
                    else {
                        slate_1.Transforms.select(editor, slateSelection);
                    }
                    slate_react_1.ReactEditor.focus(editor);
                    return;
                }
            },
            focusBlock: () => {
                if (editor.selection) {
                    // Try/catch this, as Slate may error because the selection is currently wrong
                    // TODO: catch only relevant error from Slate
                    try {
                        const [block] = Array.from(slate_1.Editor.nodes(editor, {
                            at: editor.selection.focus,
                            match: n => slate_1.Editor.isBlock(editor, n)
                        }))[0] || [undefined];
                        if (block) {
                            return values_1.fromSlateValue([block], portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            focusChild: () => {
                if (editor.selection) {
                    try {
                        const [node] = Array.from(slate_1.Editor.nodes(editor, {
                            mode: 'lowest',
                            at: editor.selection.focus,
                            match: n => n._type !== undefined,
                            voids: true
                        }))[0] || [undefined];
                        if (node && !slate_1.Editor.isBlock(editor, node)) {
                            const pseudoBlock = {
                                _key: 'pseudo',
                                _type: portableTextFeatures.types.block.name,
                                children: [node]
                            };
                            return values_1.fromSlateValue([pseudoBlock], portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0].children[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            insertChild: (type, value) => {
                var _a;
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                const [focusBlock] = Array.from(slate_1.Editor.nodes(editor, {
                    at: editor.selection.focus,
                    match: n => slate_1.Editor.isBlock(editor, n)
                }))[0] || [undefined];
                if (!focusBlock) {
                    throw new Error('No focus block');
                }
                if (focusBlock && slate_1.Editor.isVoid(editor, focusBlock)) {
                    throw new Error("Can't insert childs into block objects");
                }
                const block = values_1.toSlateValue([
                    {
                        _key: keyGenerator(),
                        _type: portableTextFeatures.types.block.name,
                        children: [
                            Object.assign({ _key: keyGenerator(), _type: type.name }, (value ? value : {}))
                        ]
                    }
                ], portableTextFeatures.types.block.name)[0];
                const child = block.children[0];
                slate_1.Editor.insertNode(editor, child);
                editor.onChange();
                return ((_a = selection_1.toPortableTextRange(editor)) === null || _a === void 0 ? void 0 : _a.focus.path) || [];
            },
            insertBlock: (type, value) => {
                var _a;
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                const block = values_1.toSlateValue([
                    Object.assign({ _key: keyGenerator(), _type: type.name }, (value ? value : {}))
                ], portableTextFeatures.types.block.name)[0];
                slate_1.Editor.insertNode(editor, block);
                editor.onChange();
                return ((_a = selection_1.toPortableTextRange(editor)) === null || _a === void 0 ? void 0 : _a.focus.path) || [];
            },
            hasBlockStyle: (style) => {
                try {
                    return editor.pteHasBlockStyle(style);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            hasListStyle: (listStyle) => {
                try {
                    return editor.pteHasListStyle(listStyle);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            isVoid: (element) => {
                return ![
                    portableTextFeatures.types.block.name,
                    portableTextFeatures.types.span.name
                ].includes(element._type);
            },
            findByPath: (path) => {
                const slatePath = selection_1.toSlateRange({ focus: { path, offset: 0 }, anchor: { path, offset: 0 } }, editor);
                if (slatePath) {
                    const [block, blockPath] = slate_1.Editor.node(editor, slatePath.focus.path.slice(0, 1));
                    if (block && blockPath && typeof block._key === 'string') {
                        if (path.length === 1 && slatePath.focus.path.length === 1) {
                            return [
                                values_1.fromSlateValue([block], portableTextFeatures.types.block.name)[0],
                                [{ _key: block._key }]
                            ];
                        }
                        const ptBlock = values_1.fromSlateValue([block], portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        const ptChild = ptBlock.children[slatePath.focus.path[1]];
                        if (ptChild) {
                            return [ptChild, [{ _key: block._key }, 'children', { _key: ptChild._key }]];
                        }
                    }
                }
                return [undefined, undefined];
            },
            findDOMNode: (element) => {
                let node;
                try {
                    const [item] = Array.from(slate_1.Editor.nodes(editor, { at: [], match: n => n._key === element._key }) || [])[0] || [undefined];
                    node = slate_react_1.ReactEditor.toDOMNode(editor, item);
                }
                catch (err) {
                    // Nothing
                }
                return node;
            },
            activeAnnotations: () => {
                if (!editor.selection || editor.selection.focus.path.length < 2) {
                    return [];
                }
                try {
                    const activeAnnotations = [];
                    const spans = slate_1.Editor.nodes(editor, {
                        at: editor.selection,
                        match: node => slate_1.Text.isText(node) && node.marks && Array.isArray(node.marks) && node.marks.length > 0
                    });
                    for (const [span, path] of spans) {
                        const [block] = slate_1.Editor.node(editor, path, { depth: 1 });
                        if (block && Array.isArray(block.markDefs)) {
                            block.markDefs.forEach(def => {
                                if (span.marks && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                                    activeAnnotations.push(def);
                                }
                            });
                        }
                    }
                    return activeAnnotations;
                }
                catch (err) {
                    return [];
                }
            },
            addAnnotation: (type, value) => {
                const { selection } = editor;
                if (selection) {
                    const [blockElement] = slate_1.Editor.node(editor, selection.focus, { depth: 1 });
                    if (blockElement._type === portableTextFeatures.types.block.name) {
                        const annotationKey = keyGenerator();
                        if (Array.isArray(blockElement.markDefs)) {
                            slate_1.Transforms.setNodes(editor, {
                                markDefs: [
                                    ...blockElement.markDefs,
                                    Object.assign({ _type: type.name, _key: annotationKey }, value)
                                ]
                            }, { at: selection.focus });
                            if (slate_1.Range.isCollapsed(selection)) {
                                editor.pteExpandToWord();
                            }
                            const [textNode] = slate_1.Editor.node(editor, selection.focus, { depth: 2 });
                            if (editor.selection) {
                                slate_1.Editor.withoutNormalizing(editor, () => {
                                    // Split if needed
                                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                                    if (editor.selection) {
                                        slate_1.Transforms.setNodes(editor, {
                                            marks: [...(textNode.marks || []), annotationKey]
                                        }, {
                                            at: editor.selection,
                                            match: n => n._type === portableTextFeatures.types.span.name
                                        });
                                    }
                                });
                                slate_1.Editor.normalize(editor);
                                editor.onChange();
                                const newSelection = selection_1.toPortableTextRange(editor);
                                if (newSelection && typeof blockElement._key === 'string') {
                                    // Insert an empty string to continue writing non-annotated text
                                    slate_1.Editor.withoutNormalizing(editor, () => {
                                        if (editor.selection) {
                                            slate_1.Transforms.insertNodes(editor, [{ _type: 'span', text: '', marks: [], _key: keyGenerator() }], {
                                                at: slate_1.Range.end(editor.selection)
                                            });
                                            editor.onChange();
                                        }
                                    });
                                    return {
                                        spanPath: newSelection.focus.path,
                                        markDefPath: [{ _key: blockElement._key }, 'markDefs', { _key: annotationKey }]
                                    };
                                }
                            }
                        }
                    }
                }
                return undefined;
            },
            delete: (selection, options) => {
                if (selection) {
                    const range = selection_1.toSlateRange(selection, editor);
                    if (range) {
                        const ptMode = (options && options.mode) || undefined;
                        let mode;
                        if (ptMode) {
                            mode = mode === 'block' ? 'highest' : 'lowest';
                        }
                        slate_1.Transforms.removeNodes(editor, { at: range, mode });
                    }
                }
            },
            removeAnnotation: (type) => {
                let { selection } = editor;
                let changed = false;
                if (selection) {
                    // Select the whole annotation if collapsed
                    if (slate_1.Range.isCollapsed(selection)) {
                        const [node, nodePath] = slate_1.Editor.node(editor, selection, { depth: 2 });
                        if (node && node.marks && typeof node.text === 'string') {
                            slate_1.Transforms.select(editor, nodePath);
                            selection = editor.selection;
                        }
                    }
                    if (selection && slate_1.Range.isExpanded(selection)) {
                        // Split the span first
                        slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                        selection = editor.selection;
                        if (!selection) {
                            return;
                        }
                        // Everything in the selection which has marks
                        const spans = slate_1.Editor.nodes(editor, {
                            at: selection,
                            match: node => slate_1.Text.isText(node) &&
                                node.marks &&
                                Array.isArray(node.marks) &&
                                node.marks.length > 0
                        });
                        for (const [span, path] of spans) {
                            const [block] = slate_1.Editor.node(editor, path, { depth: 1 });
                            if (block && Array.isArray(block.markDefs)) {
                                block.markDefs.forEach(def => {
                                    if (def._type === type.name &&
                                        span.marks &&
                                        Array.isArray(span.marks) &&
                                        span.marks.includes(def._key)) {
                                        slate_1.Transforms.setNodes(editor, {
                                            marks: [...(span.marks || []).filter(mark => mark !== def._key)]
                                        }, { at: path, voids: false, split: false });
                                        changed = true;
                                    }
                                });
                            }
                            // Merge similar adjecent spans
                            if (changed) {
                                for (const [node, path] of Array.from(slate_1.Editor.nodes(editor, {
                                    at: slate_1.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]]),
                                    match: slate_1.Text.isText
                                })).reverse()) {
                                    const [parent] = slate_1.Editor.node(editor, slate_1.Path.parent(path));
                                    if (slate_1.Editor.isBlock(editor, parent)) {
                                        const nextPath = [path[0], path[1] + 1];
                                        const nextTextNode = parent.children[nextPath[1]];
                                        if (nextTextNode &&
                                            typeof nextTextNode.text === 'string' &&
                                            lodash_1.isEqual(nextTextNode.marks, node.marks)) {
                                            slate_1.Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                                        }
                                    }
                                }
                            }
                        }
                        if (changed) {
                            editor.onChange();
                        }
                    }
                }
            },
            getSelection: () => {
                return selection_1.toPortableTextRange(editor);
            },
            getValue: () => {
                return values_1.fromSlateValue(editor.children, portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor));
            },
            isCollapsedSelection: () => {
                return !!editor.selection && slate_1.Range.isCollapsed(editor.selection);
            },
            isExpandedSelection: () => {
                return !!editor.selection && slate_1.Range.isExpanded(editor.selection);
            }
        });
        return editor;
    };
}
exports.createWithEditableAPI = createWithEditableAPI;
//# sourceMappingURL=createWithEditableAPI.js.map