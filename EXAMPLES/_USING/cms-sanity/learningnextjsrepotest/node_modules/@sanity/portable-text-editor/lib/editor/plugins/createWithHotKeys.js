"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithHotkeys = void 0;
const slate_1 = require("slate");
const is_hotkey_1 = __importDefault(require("is-hotkey"));
const debug_1 = require("../../utils/debug");
const values_1 = require("../../utils/values");
const debug = debug_1.debugWithName('plugin:withHotKeys');
const DEFAULT_HOTKEYS = {
    marks: {
        'mod+b': 'strong',
        'mod+i': 'em',
        'mod+u': 'underline',
        "mod+'": 'code'
    },
    custom: {}
};
/**
 * This plugin takes care of all hotkeys in the editor
 * TODO: move a lot of these out the their respective plugins
 *
 */
function createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeysFromOptions) {
    const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end'];
    const activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS; // TODO: Merge where possible? A union?
    return function withHotKeys(editor) {
        editor.pteWithHotKeys = (event) => {
            // Wire up custom marks hotkeys
            Object.keys(activeHotkeys).forEach(cat => {
                if (cat === 'marks') {
                    for (const hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error(`The hotkey ${hotkey} is reserved!`);
                        }
                        if (is_hotkey_1.default(hotkey, event.nativeEvent)) {
                            event.preventDefault();
                            const possibleMark = activeHotkeys[cat];
                            if (possibleMark) {
                                const mark = possibleMark[hotkey];
                                debug(`HotKey ${hotkey} to toggle ${mark}`);
                                editor.pteToggleMark(mark);
                            }
                        }
                    }
                }
                if (cat === 'custom') {
                    for (const hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error(`The hotkey ${hotkey} is reserved!`);
                        }
                        if (is_hotkey_1.default(hotkey, event.nativeEvent)) {
                            const possibleCommand = activeHotkeys[cat];
                            if (possibleCommand) {
                                const command = possibleCommand[hotkey];
                                command(event, portableTextEditor);
                            }
                        }
                    }
                }
            });
            const isEnter = is_hotkey_1.default('enter', event.nativeEvent);
            const isTab = is_hotkey_1.default('tab', event.nativeEvent);
            const isShiftEnter = is_hotkey_1.default('shift+enter', event.nativeEvent);
            const isShiftTab = is_hotkey_1.default('shift+tab', event.nativeEvent);
            const isBackspace = is_hotkey_1.default('backspace', event.nativeEvent);
            const isDelete = is_hotkey_1.default('delete', event.nativeEvent);
            // Handle inline objects delete and backspace (not implemented in Slate)
            // TODO: implement cut for inline objects (preferably in Slate)
            if ((isDelete || isBackspace) && editor.selection && slate_1.Range.isCollapsed(editor.selection)) {
                const [focusChild] = slate_1.Editor.node(editor, editor.selection.focus, { depth: 2 });
                if (slate_1.Editor.isVoid(editor, focusChild) && slate_1.Editor.isInline(editor, focusChild)) {
                    slate_1.Transforms.delete(editor, { at: editor.selection, voids: false, hanging: true });
                    slate_1.Transforms.collapse(editor);
                    editor.onChange();
                }
            }
            // Disallow deleting void blocks by backspace from another line.
            // Otherwise it's so easy to delete the void block above when trying to delete text on
            // the line below or above
            if (isBackspace &&
                editor.selection &&
                editor.selection.focus.path[0] > 0 &&
                slate_1.Range.isCollapsed(editor.selection)) {
                const [prevBlock, prevPath] = slate_1.Editor.node(editor, slate_1.Path.previous(editor.selection.focus.path.slice(0, 1)));
                const [focusBlock] = slate_1.Editor.node(editor, editor.selection.focus, { depth: 1 });
                if (prevBlock &&
                    focusBlock &&
                    slate_1.Editor.isVoid(editor, prevBlock) &&
                    editor.selection.focus.offset === 0) {
                    debug('Preventing deleting void block above');
                    event.preventDefault();
                    event.stopPropagation();
                    slate_1.Transforms.removeNodes(editor, { match: n => n === focusBlock });
                    slate_1.Transforms.select(editor, prevPath);
                    editor.onChange();
                    return true;
                }
            }
            if (isDelete &&
                editor.selection &&
                editor.selection.focus.offset === 0 &&
                slate_1.Range.isCollapsed(editor.selection) &&
                editor.children[editor.selection.focus.path[0] + 1]) {
                const [nextBlock] = slate_1.Editor.node(editor, slate_1.Path.next(editor.selection.focus.path.slice(0, 1)));
                const [focusBlock, focusBlockPath] = slate_1.Editor.node(editor, editor.selection.focus, { depth: 1 });
                if (nextBlock &&
                    focusBlock &&
                    !slate_1.Editor.isVoid(editor, focusBlock) &&
                    slate_1.Editor.isVoid(editor, nextBlock)) {
                    debug('Preventing deleting void block below');
                    event.preventDefault();
                    event.stopPropagation();
                    slate_1.Transforms.removeNodes(editor, { match: n => n === focusBlock });
                    slate_1.Transforms.select(editor, focusBlockPath);
                    editor.onChange();
                    return true;
                }
            }
            // There's a bug in Slate atm regarding void nodes not being deleted if it is the last block.
            // Seems related to 'hanging: true'. 2020/05/26
            if ((isDelete || isBackspace) && editor.selection && slate_1.Range.isExpanded(editor.selection)) {
                event.preventDefault();
                event.stopPropagation();
                slate_1.Transforms.delete(editor, { at: editor.selection, voids: false, hanging: true });
                slate_1.Transforms.collapse(editor);
                editor.onChange();
                return true;
            }
            // Tab for lists
            if (isTab || isShiftTab) {
                editor.pteIncrementBlockLevels(isShiftTab) && event.preventDefault();
            }
            // Deal with enter key combos
            if (isEnter && !isShiftEnter && editor.selection) {
                let focusBlock;
                try {
                    ;
                    [focusBlock] = slate_1.Editor.node(editor, editor.selection.focus, { depth: 1 });
                }
                catch (err) {
                    // Just ignore
                }
                // List item enter key
                if (focusBlock && focusBlock.listItem) {
                    editor.pteEndList() && event.preventDefault();
                    return;
                }
                // Block object enter key
                if (focusBlock && slate_1.Editor.isVoid(editor, focusBlock)) {
                    const block = values_1.toSlateValue([
                        {
                            _type: portableTextFeatures.types.block.name,
                            _key: keyGenerator(),
                            style: 'normal',
                            markDefs: [],
                            children: [
                                {
                                    _type: 'span',
                                    _key: keyGenerator(),
                                    text: '',
                                    marks: []
                                }
                            ]
                        }
                    ], portableTextFeatures.types.block.name)[0];
                    slate_1.Editor.insertNode(editor, block);
                    event.preventDefault();
                    return;
                }
            }
            // Soft line breaks
            if (isShiftEnter) {
                event.preventDefault();
                editor.insertText('\n');
                return;
            }
            // Undo/redo
            if (is_hotkey_1.default('mod+z', event.nativeEvent)) {
                event.preventDefault();
                editor.undo();
                return;
            }
            if (is_hotkey_1.default('mod+y', event.nativeEvent) || is_hotkey_1.default('mod+shift+z', event.nativeEvent)) {
                event.preventDefault();
                editor.redo();
                return;
            }
        };
        return editor;
    };
}
exports.createWithHotkeys = createWithHotkeys;
//# sourceMappingURL=createWithHotKeys.js.map