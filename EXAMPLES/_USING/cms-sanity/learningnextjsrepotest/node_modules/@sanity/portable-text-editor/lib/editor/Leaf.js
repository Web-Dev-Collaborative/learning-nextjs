"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Leaf = void 0;
const react_1 = __importDefault(require("react"));
const slate_1 = require("slate");
const slate_react_1 = require("@sanity/slate-react");
const lodash_1 = require("lodash");
const DefaultAnnotation_1 = require("./nodes/DefaultAnnotation");
const debug_1 = require("../utils/debug");
const DraggableChild_1 = require("./DraggableChild");
const debug = debug_1.debugWithName('components:Leaf');
const debugRenders = false;
exports.Leaf = (props) => {
    const editor = slate_react_1.useEditor();
    const selected = slate_react_1.useSelected();
    const { attributes, children, leaf, portableTextFeatures, keyGenerator, renderChild } = props;
    const spanRef = react_1.default.useRef(null);
    let returnedChildren = children;
    const focused = (selected && editor.selection && slate_1.Range.isCollapsed(editor.selection)) || false;
    if (leaf._type === portableTextFeatures.types.span.name) {
        const blockElement = children.props.parent;
        const path = [{ _key: blockElement._key }, 'children', { _key: leaf._key }];
        const decoratorValues = portableTextFeatures.decorators.map(dec => dec.value);
        const marks = lodash_1.uniq((Array.isArray(leaf.marks) ? leaf.marks : []).filter(mark => decoratorValues.includes(mark)));
        marks.map(mark => {
            var _a, _b;
            const type = portableTextFeatures.decorators.find(dec => dec.value === mark);
            if (type) {
                // TODO: look into this API!
                if ((_a = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _a === void 0 ? void 0 : _a.render) {
                    const CustomComponent = (_b = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _b === void 0 ? void 0 : _b.render;
                    returnedChildren = react_1.default.createElement(CustomComponent, { mark: mark }, returnedChildren);
                }
                if (props.renderDecorator) {
                    returnedChildren = props.renderDecorator(mark, type, { focused, selected, path }, () => react_1.default.createElement(react_1.default.Fragment, null, returnedChildren), spanRef);
                }
            }
        });
        const annotations = (Array.isArray(leaf.marks) ? leaf.marks : [])
            .map(mark => !decoratorValues.includes(mark) &&
            blockElement &&
            blockElement.markDefs &&
            blockElement.markDefs.find(def => def._key === mark))
            .filter(Boolean);
        const handleMouseDown = event => {
            // Slate will deselect this when it is already selected and clicked again, so prevent that. 2020/05/04
            if (focused) {
                event.stopPropagation();
                event.preventDefault();
            }
        };
        if (annotations.length > 0) {
            annotations.map(annotation => {
                var _a;
                const type = portableTextFeatures.types.annotations.find(t => t.name === annotation._type);
                // TODO: look into this API!
                const CustomComponent = (_a = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _a === void 0 ? void 0 : _a.render;
                const defaultRender = () => 
                // TODO: annotation should be an own prop here, keeping for backward compability (2020/05/18).
                CustomComponent ? (react_1.default.createElement(CustomComponent, Object.assign({}, annotation, { attributes: attributes }), returnedChildren)) : (react_1.default.createElement(react_1.default.Fragment, null, returnedChildren));
                if (type) {
                    if (!props.renderAnnotation) {
                        returnedChildren = (react_1.default.createElement(DefaultAnnotation_1.DefaultAnnotation, { attributes: attributes, annotation: annotation },
                            react_1.default.createElement("span", { ref: spanRef, key: keyGenerator(), onMouseDown: handleMouseDown }, defaultRender())));
                    }
                    else {
                        returnedChildren = (react_1.default.createElement("span", { ref: spanRef, key: keyGenerator() }, props.renderAnnotation(annotation, type, { focused, selected, path, annotations }, defaultRender, spanRef)));
                    }
                }
            });
        }
        if (renderChild) {
            const child = blockElement.children.find(child => child._key === leaf._key); // Ensure object equality
            returnedChildren = renderChild(child, portableTextFeatures.types.span, { focused, selected, path, annotations }, () => returnedChildren, spanRef);
        }
    }
    debugRenders && debug(`Render ${leaf._key} (span)`);
    const key = leaf._key || keyGenerator();
    // TODO: remove hightlight stuff as test for decorations
    return (react_1.default.createElement("span", Object.assign({}, attributes, { style: { backgroundColor: leaf.__highlight ? '#ff0' : 'inherit' }, ref: spanRef, key: key }),
        react_1.default.createElement(DraggableChild_1.DraggableChild, { element: leaf, readOnly: props.readOnly, spanType: portableTextFeatures.types.span.name, keyGenerator: props.keyGenerator }, returnedChildren)));
};
//# sourceMappingURL=Leaf.js.map