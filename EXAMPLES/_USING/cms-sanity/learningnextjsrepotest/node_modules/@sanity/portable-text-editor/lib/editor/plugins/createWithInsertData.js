"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithInsertData = void 0;
const slate_1 = require("slate");
const block_tools_1 = require("@sanity/block-tools");
const values_1 = require("../../utils/values");
const validateValue_1 = require("../../utils/validateValue");
const debug_1 = require("../../utils/debug");
const debug = debug_1.debugWithName('plugin:withInsertData');
/**
 * This plugin handles pasting and drag/drop to the editor
 *
 */
function createWithInsertData(change$, portableTextFeatures, keyGenerator) {
    return function withInsertData(editor) {
        const { setFragmentData } = editor;
        editor.setFragmentData = (data) => {
            debug('Set fragment data');
            setFragmentData(data);
        };
        editor.getFragment = () => {
            debug('Get fragment data');
            if (editor.selection) {
                const fragment = slate_1.Node.fragment(editor, editor.selection).map(node => {
                    const newNode = Object.assign({}, node);
                    // Ensure the copy has new keys
                    if (newNode.markDefs && Array.isArray(newNode.markDefs)) {
                        newNode.markDefs = newNode.markDefs.map(def => {
                            const oldKey = def._key;
                            const newKey = keyGenerator();
                            if (Array.isArray(newNode.children)) {
                                newNode.children = newNode.children.map(child => child._type === portableTextFeatures.types.span.name
                                    ? Object.assign(Object.assign({}, child), { marks: child.marks.includes(oldKey)
                                            ? [...child.marks].filter(mark => mark !== oldKey).concat(newKey)
                                            : child.marks }) : child);
                            }
                            return Object.assign(Object.assign({}, def), { _key: newKey });
                        });
                    }
                    const nodeWithNewKeys = Object.assign(Object.assign({}, newNode), { _key: keyGenerator() });
                    if (Array.isArray(nodeWithNewKeys.children)) {
                        nodeWithNewKeys.children = nodeWithNewKeys.children.map(child => (Object.assign(Object.assign({}, child), { _key: keyGenerator() })));
                    }
                    return nodeWithNewKeys;
                });
                return fragment;
            }
            return [];
        };
        editor.insertData = data => {
            var _a;
            if (!editor.selection) {
                debug('No selection, not inserting');
                return;
            }
            change$.next({ type: 'loading', isLoading: true }); // This could potenitally take some time
            const html = data.getData('text/html');
            const slateFragment = data.getData('application/x-slate-fragment');
            const text = data.getData('text/plain');
            // TODO: support application/x-portable-text ?
            // const portableText = data.getData('application/x-portable-text')
            // if (portableText) {
            //   const parsed = JSON.parse(portableText)
            //   if (Array.isArray(parsed) && parsed.length > 0) {
            //     debug('inserting portable text', parsed)
            //     return true
            //   }
            // }
            const originalSelection = Object.assign({}, editor.selection);
            const isBackward = slate_1.Range.isBackward(editor.selection);
            if (slateFragment || html || text) {
                let portableText;
                let fragment;
                let insertedType;
                if (slateFragment) {
                    // Slate fragments
                    const decoded = decodeURIComponent(window.atob(slateFragment));
                    fragment = JSON.parse(decoded);
                    portableText = values_1.fromSlateValue(fragment, portableTextFeatures.types.block.name);
                    insertedType = 'Slate Fragment';
                }
                else if (html) {
                    // HTML (TODO: get rid of @sanity/block-tools)
                    portableText = block_tools_1.htmlToBlocks(html, portableTextFeatures.types.portableText)
                        // Ensure it has keys
                        .map(block => block_tools_1.normalizeBlock(block, { blockTypeName: portableTextFeatures.types.block.name }));
                    fragment = values_1.toSlateValue(portableText, portableTextFeatures.types.block.name);
                    insertedType = 'HTML';
                }
                else {
                    // plain text
                    const blocks = escapeHtml(text)
                        .split(/\n{2,}/)
                        .map(line => (line ? `<p>${line.replace(/(?:\r\n|\r|\n)/g, '<br/>')}</p>` : '<p></p>'))
                        .join('');
                    const textToHtml = `<html><body>${blocks}</body></html>`;
                    portableText = block_tools_1.htmlToBlocks(textToHtml, portableTextFeatures.types.portableText);
                    fragment = values_1.toSlateValue(portableText, portableTextFeatures.types.block.name);
                    insertedType = 'text';
                }
                // Validate the result
                const validation = validateValue_1.validateValue(portableText, portableTextFeatures, keyGenerator);
                // Bail out if it's not valid
                if (!validation.valid) {
                    const errorDescription = `Could not validate the resulting portable text to insert.\n${(_a = validation.resolution) === null || _a === void 0 ? void 0 : _a.description}\nTry to insert as plain text (shift-paste) instead.`;
                    change$.next({
                        type: 'error',
                        level: 'warning',
                        name: 'pasteError',
                        description: errorDescription,
                        data: validation
                    });
                    debug('Invalid insert result', validation);
                    return;
                }
                let insertAtPath = editor.selection[isBackward ? 'focus' : 'anchor'].path.slice(0, 1);
                debug(`Inserting ${insertedType} fragment at ${JSON.stringify(insertAtPath)}`, fragment);
                const [focusBlock] = slate_1.Editor.node(editor, editor.selection, { depth: 1 });
                const focusIsVoid = slate_1.Editor.isVoid(editor, focusBlock);
                if (focusIsVoid) {
                    // Insert at path below the void block as we can't insert *into* it.
                    insertAtPath = [insertAtPath[0] + 1];
                }
                fragment.forEach((blk, blkIndex) => {
                    const { markDefs } = blk;
                    if (fragment[0] === blk && !focusIsVoid) {
                        const isVoid = slate_1.Editor.isVoid(editor, fragment[0]);
                        const isEmptyText = values_1.isEqualToEmptyEditor([focusBlock], portableTextFeatures);
                        if (isEmptyText && isVoid) {
                            slate_1.Transforms.insertFragment(editor, [blk], {
                                at: insertAtPath
                            });
                            slate_1.Transforms.removeNodes(editor, { at: insertAtPath });
                            if (fragment.length === 1) {
                                slate_1.Transforms.setSelection(editor, {
                                    focus: { path: insertAtPath, offset: 0 },
                                    anchor: { path: insertAtPath, offset: 0 }
                                });
                            }
                        }
                        else {
                            slate_1.Transforms.insertFragment(editor, [blk]);
                        }
                        if (!focusIsVoid && !isVoid) {
                            // As the first block will be inserted into another block (potentially), mix those markDefs
                            slate_1.Transforms.setNodes(editor, {
                                markDefs: [
                                    ...(Array.isArray(focusBlock.markDefs) ? focusBlock.markDefs : []),
                                    ...(Array.isArray(markDefs) ? markDefs : [])
                                ]
                            }, { at: insertAtPath });
                            // If the focus block is not empty, use the style from the block.
                            if (isEmptyText ||
                                (originalSelection.anchor.path[0] === 0 &&
                                    originalSelection.anchor.path[1] === 0 &&
                                    originalSelection.anchor.offset === 0)) {
                                slate_1.Transforms.setNodes(editor, { style: blk.style }, { at: insertAtPath });
                            }
                            else {
                                slate_1.Transforms.setNodes(editor, { style: focusBlock.style }, { at: insertAtPath });
                            }
                        }
                    }
                    else {
                        if (blkIndex === 1) {
                            slate_1.Transforms.splitNodes(editor);
                        }
                        slate_1.Transforms.insertNodes(editor, [blk], { at: insertAtPath, select: true });
                    }
                    insertAtPath = [insertAtPath[0] + 1];
                });
                change$.next({ type: 'loading', isLoading: false });
                editor.onChange();
                return;
            }
            change$.next({ type: 'loading', isLoading: false });
        };
        return editor;
    };
}
exports.createWithInsertData = createWithInsertData;
const entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
};
function escapeHtml(string) {
    return String(string).replace(/[&<>"'`=\/]/g, function (s) {
        return entityMap[s];
    });
}
//# sourceMappingURL=createWithInsertData.js.map