"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithSchemaTypes = void 0;
const debug_1 = require("../../utils/debug");
const debug = debug_1.debugWithName('plugin:withSchemaTypes');
/**
 * This plugin makes sure that shema types are recognized properly by Slate as blocks, voids, inlines
 *
 */
function createWithSchemaTypes(portableTextFeatures) {
    return function withSchemaTypes(editor) {
        editor.isVoid = (element) => {
            return (typeof element._type === 'string' &&
                portableTextFeatures.types.block.name !== element._type &&
                (portableTextFeatures.types.blockObjects.map(obj => obj.name).includes(element._type) ||
                    portableTextFeatures.types.inlineObjects.map(obj => obj.name).includes(element._type)));
        };
        editor.isInline = (element) => {
            const inlineSchemaTypes = portableTextFeatures.types.inlineObjects.map(obj => obj.name);
            return (typeof element._type === 'string' &&
                inlineSchemaTypes.includes(element._type) &&
                element.__inline === true);
        };
        // Extend Slate's default normalization to add _type span to span inserted after a inline void object
        const { apply } = editor;
        editor.apply = (op) => {
            const isInsertTextWithoutType = op.type === 'insert_node' && op.path.length === 2 && op.node._type === undefined;
            if (isInsertTextWithoutType) {
                const insertNodeOperation = op;
                const newNode = Object.assign(Object.assign({}, insertNodeOperation.node), { _type: portableTextFeatures.types.span.name });
                op.node = newNode;
                debug('Setting span type to child without a type', op);
            }
            apply(op);
        };
        return editor;
    };
}
exports.createWithSchemaTypes = createWithSchemaTypes;
//# sourceMappingURL=createWithSchemaTypes.js.map