"use strict";
/**
 *
 * This plugin will change Slate's default marks model (every prop is a mark) with the Portable Text model (marks is an array of strings on prop .marks).
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithPortableTextMarkModel = void 0;
const lodash_1 = require("lodash");
const slate_1 = require("slate");
const debug_1 = require("../../utils/debug");
const selection_1 = require("../../utils/selection");
const debug = debug_1.debugWithName('plugin:withPortableTextMarkModel');
function createWithPortableTextMarkModel(portableTextFeatures, keyGenerator, change$) {
    return function withPortableTextMarkModel(editor) {
        const { apply, normalizeNode } = editor;
        const decorators = portableTextFeatures.decorators.map(t => t.value);
        // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations, and clean up markDefs / marks
        editor.normalizeNode = nodeEntry => {
            normalizeNode(nodeEntry);
            const [node, path] = nodeEntry;
            const isBlock = node._type === portableTextFeatures.types.block.name;
            const isSpan = node._type === portableTextFeatures.types.span.name;
            if (isSpan) {
                if (!node.marks) {
                    debug('Adding .marks to span node');
                    slate_1.Transforms.setNodes(editor, { marks: [] }, { at: path });
                    editor.onChange();
                }
                if (editor.operations.some(op => [
                    'insert_node',
                    'insert_text',
                    'merge_node',
                    'remove_node',
                    'remove_text',
                    'set_node'
                ].includes(op.type))) {
                    mergeSpans(editor);
                }
                for (const op of editor.operations) {
                    // Make sure markDefs are copied over when merging two blocks.
                    if (op.type === 'merge_node' &&
                        op.path.length === 1 &&
                        op.properties._type === portableTextFeatures.types.block.name &&
                        Array.isArray(op.properties.markDefs) &&
                        op.properties.markDefs.length > 0 &&
                        op.path[0] - 1 >= 0) {
                        const [targetBlock, targetPath] = slate_1.Editor.node(editor, [op.path[0] - 1]);
                        debug(`Copying markDefs over to merged block`, op);
                        if (targetBlock) {
                            const oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                            slate_1.Transforms.setNodes(editor, { markDefs: lodash_1.uniq([...oldDefs, ...op.properties.markDefs]) }, { at: targetPath, voids: false });
                            editor.onChange();
                        }
                    }
                    // Make sure markDefs are copied over to new block when splitting a block.
                    if (op.type === 'split_node' &&
                        op.path.length === 1 &&
                        op.properties._type === portableTextFeatures.types.block.name &&
                        Array.isArray(op.properties.markDefs) &&
                        op.properties.markDefs.length > 0 &&
                        op.path[0] + 1 < editor.children.length) {
                        const [targetBlock, targetPath] = slate_1.Editor.node(editor, [op.path[0] + 1]);
                        debug(`Copying markDefs over to split block`, op);
                        if (targetBlock) {
                            const oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                            slate_1.Transforms.setNodes(editor, { markDefs: lodash_1.uniq([...oldDefs, ...op.properties.markDefs]) }, { at: targetPath, voids: false });
                            editor.onChange();
                        }
                    }
                    // Make sure marks are reset, if a block is split at the end.
                    if (op.type === 'split_node' &&
                        op.path.length === 2 &&
                        op.properties._type === portableTextFeatures.types.span.name &&
                        Array.isArray(op.properties.marks) &&
                        op.properties.marks.length > 0 &&
                        op.path[0] + 1 < editor.children.length) {
                        const [child, childPath] = slate_1.Editor.node(editor, [op.path[0] + 1, 0]);
                        if (child &&
                            child.text === '' &&
                            Array.isArray(child.marks) &&
                            child.marks.length > 0) {
                            slate_1.Transforms.setNodes(editor, { marks: [] }, { at: childPath, voids: false });
                            editor.onChange();
                        }
                    }
                }
                // Remove marks if text is empty
                if (Array.isArray(node.marks) && node.marks.length > 0 && node.text === '') {
                    slate_1.Transforms.setNodes(editor, { marks: [] }, { at: path, voids: false });
                    editor.onChange();
                }
            }
            // Check consistency of markDefs
            if (isBlock &&
                editor.operations.some(op => ['split_node', 'remove_node', 'remove_text', 'merge_node'].includes(op.type))) {
                normalizeMarkDefs(editor);
            }
        };
        // Special hook before inserting text at the end of an annotation.
        editor.apply = op => {
            var _a, _b;
            if (op.type === 'insert_text') {
                const { selection } = editor;
                if (selection &&
                    slate_1.Range.isCollapsed(selection) && ((_b = (_a = slate_1.Editor.marks(editor)) === null || _a === void 0 ? void 0 : _a.marks) === null || _b === void 0 ? void 0 : _b.some(mark => !decorators.includes(mark)))) {
                    const [node] = Array.from(slate_1.Editor.nodes(editor, {
                        mode: 'lowest',
                        at: selection.focus,
                        match: n => n._type === portableTextFeatures.types.span.name,
                        voids: false
                    }))[0] || [undefined];
                    if (node &&
                        node.text &&
                        typeof node.text === 'string' &&
                        node.text.length === selection.focus.offset &&
                        Array.isArray(node.marks) &&
                        node.marks.length > 0) {
                        apply(op);
                        slate_1.Transforms.splitNodes(editor, {
                            match: slate_1.Text.isText,
                            at: Object.assign(Object.assign({}, selection.focus), { offset: selection.focus.offset })
                        });
                        const marksWithoutAnnotationMarks = (Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || []).filter(mark => decorators.includes(mark));
                        slate_1.Transforms.setNodes(editor, { marks: marksWithoutAnnotationMarks }, { at: slate_1.Path.next(selection.focus.path) });
                        return;
                    }
                }
            }
            apply(op);
        };
        // Override built in addMark function
        editor.addMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    // Use new selection
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    const shouldRemoveMark = lodash_1.flatten(splitTextNodes.map(item => item[0]).map(node => node.marks)).includes(mark);
                    if (shouldRemoveMark) {
                        editor.removeMark(mark);
                        return;
                    }
                    splitTextNodes.forEach(([node, path]) => {
                        const marks = [
                            ...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
                            mark
                        ];
                        slate_1.Transforms.setNodes(editor, { marks }, { at: path });
                    });
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: [...existingMarks, mark] });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        // Override built in removeMark function
        editor.removeMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    splitTextNodes.forEach(([node, path]) => {
                        slate_1.Transforms.setNodes(editor, {
                            marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark)
                        }, { at: path });
                    });
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: existingMarks.filter(eMark => eMark !== mark) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        editor.pteIsMarkActive = (mark) => {
            if (!editor.selection) {
                return false;
            }
            let existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
            if (slate_1.Range.isExpanded(editor.selection)) {
                Array.from(slate_1.Editor.nodes(editor, { match: slate_1.Text.isText, at: editor.selection })).forEach(n => {
                    const [node] = n;
                    existingMarks = lodash_1.uniq([...existingMarks, ...(node.marks || [])]);
                });
            }
            return existingMarks.includes(mark);
        };
        // Custom editor function to toggle a mark
        editor.pteToggleMark = (mark) => {
            const isActive = editor.pteIsMarkActive(mark);
            if (isActive) {
                debug(`Remove mark '${mark}'`);
                slate_1.Editor.removeMark(editor, mark);
            }
            else {
                debug(`Add mark '${mark}'`);
                slate_1.Editor.addMark(editor, mark, true);
            }
            const newSelection = selection_1.toPortableTextRange(editor);
            if (newSelection) {
                // Emit a new selection here (though it might be the same).
                // This is for toolbars etc that listens to selection changes to update themselves.
                change$.next({ type: 'selection', selection: newSelection });
            }
            editor.onChange();
        };
        return editor;
    };
    /**
     * Normalize re-marked spans in selection
     * @param {Editor} editor
     */
    function mergeSpans(editor) {
        const { selection } = editor;
        if (selection) {
            for (const [node, path] of Array.from(slate_1.Editor.nodes(editor, {
                at: slate_1.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])
            })).reverse()) {
                const [parent] = path.length > 1 ? slate_1.Editor.node(editor, slate_1.Path.parent(path)) : [undefined];
                const nextPath = [path[0], path[1] + 1];
                if (slate_1.Editor.isBlock(editor, parent)) {
                    const nextNode = parent.children[nextPath[1]];
                    if (node._type === 'span' &&
                        nextNode &&
                        nextNode._type === 'span' &&
                        lodash_1.isEqual(nextNode.marks, node.marks)) {
                        debug('Merging spans');
                        slate_1.Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                        editor.onChange();
                    }
                }
            }
        }
    }
    /**
     * Normalize markDefs
     *
     * @param {Editor} editor
     */
    function normalizeMarkDefs(editor) {
        const { selection } = editor;
        if (selection) {
            const blocks = slate_1.Editor.nodes(editor, {
                at: selection,
                match: n => n._type === portableTextFeatures.types.block.name
            });
            for (const [block, path] of blocks) {
                if (Array.isArray(block.markDefs) && slate_1.Element.isElement(block)) {
                    const newMarkDefs = block.markDefs.filter(def => {
                        return block.children.find(child => {
                            return Array.isArray(child.marks) && child.marks.includes(def._key);
                        });
                    });
                    if (!lodash_1.isEqual(newMarkDefs, block.markDefs)) {
                        debug('Removing markDef not in use');
                        slate_1.Transforms.setNodes(editor, {
                            markDefs: newMarkDefs
                        }, { at: path });
                        editor.onChange();
                    }
                }
            }
        }
    }
}
exports.createWithPortableTextMarkModel = createWithPortableTextMarkModel;
//# sourceMappingURL=createWithPortableTextMarkModel.js.map