"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortableTextEditable = void 0;
const slate_1 = require("slate");
const lodash_1 = require("lodash");
const is_hotkey_1 = __importDefault(require("is-hotkey"));
const block_tools_1 = require("@sanity/block-tools");
const react_1 = __importStar(require("react"));
const slate_react_1 = require("@sanity/slate-react");
const createWithEditableAPI_1 = require("./plugins/createWithEditableAPI");
const values_1 = require("../utils/values");
const copyPaste_1 = require("../utils/copyPaste");
const plugins_1 = require("./plugins");
const Leaf_1 = require("./Leaf");
const Element_1 = require("./Element");
const withPortableText_1 = require("./withPortableText");
const selection_1 = require("../utils/selection");
const debug_1 = require("../utils/debug");
const usePortableTextEditor_1 = require("./hooks/usePortableTextEditor");
const usePortableTextEditorValue_1 = require("./hooks/usePortableTextEditorValue");
const PortableTextEditor_1 = require("./PortableTextEditor");
const weakMaps_1 = require("../utils/weakMaps");
const debug = debug_1.debugWithName('component:Editable');
// Weakmap for testing if we need to update the state value from a new value coming in from props
const VALUE_TO_SLATE_VALUE = new WeakMap();
const SELECT_TOP_DOCUMENT = { anchor: { path: [0, 0], offset: 0 }, focus: { path: [0, 0], offset: 0 } };
exports.PortableTextEditable = (props) => {
    const { hotkeys, placeholderText, spellCheck } = props;
    const portableTextEditor = usePortableTextEditor_1.usePortableTextEditor();
    const value = usePortableTextEditorValue_1.usePortableTextEditorValue();
    const { change$, isThrottling, incomingPatche$, keyGenerator, maxBlocks, portableTextFeatures, readOnly } = portableTextEditor;
    const createPlaceHolderBlock = () => ({
        _type: portableTextFeatures.types.block.name,
        _key: keyGenerator(),
        style: 'normal',
        markDefs: [],
        children: [
            {
                _type: 'span',
                _key: keyGenerator(),
                text: '',
                marks: []
            }
        ]
    });
    // React/UI-spesific plugins
    const withInsertData = react_1.useMemo(() => plugins_1.createWithInsertData(change$, portableTextFeatures, keyGenerator), []);
    const withHotKeys = react_1.useMemo(() => plugins_1.createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeys), []);
    // Create the PortableTextEditor API
    const withEditableAPI = react_1.useMemo(() => createWithEditableAPI_1.createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator), []);
    // Init the Slate Editor
    const editor = react_1.useMemo(() => withHotKeys(withInsertData(withEditableAPI(slate_react_1.withReact(withPortableText_1.withPortableText(slate_1.createEditor(), {
        portableTextFeatures: portableTextFeatures,
        keyGenerator,
        change$,
        maxBlocks,
        incomingPatche$,
        readOnly
    }))))), []);
    // Track editor value
    const [stateValue, setStateValue] = react_1.useState(
    // Default value
    values_1.toSlateValue(getValueOrIntitialValue(value, [createPlaceHolderBlock()]), portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_SLATE_ELEMENT.get(editor)));
    // Track selection state
    const [selection, setSelection] = react_1.useState(editor.selection);
    const [isSelecting, setIsSelecting] = react_1.useState(false);
    const renderElement = react_1.useCallback(eProps => {
        if (values_1.isEqualToEmptyEditor(editor.children, portableTextFeatures)) {
            return react_1.default.createElement("div", Object.assign({}, eProps.attributes), eProps.children);
        }
        return (react_1.default.createElement(Element_1.Element, Object.assign({}, eProps, { keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, readOnly: readOnly, renderBlock: props.renderBlock, renderChild: props.renderChild })));
    }, [value]);
    const renderLeaf = react_1.useCallback(lProps => {
        if (values_1.isEqualToEmptyEditor(editor.children, portableTextFeatures)) {
            return react_1.default.createElement("span", Object.assign({}, lProps.attributes), lProps.children);
        }
        return (react_1.default.createElement(Leaf_1.Leaf, Object.assign({}, lProps, { keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, renderAnnotation: props.renderAnnotation, renderChild: props.renderChild, renderDecorator: props.renderDecorator, readOnly: readOnly })));
    }, [value]);
    const handleChange = val => {
        if (val !== stateValue) {
            setStateValue(val);
        }
        if (editor.selection !== selection) {
            setSelection(editor.selection);
        }
    };
    // // Test Slate decorations. Highlight the word 'w00t'
    // // TODO: remove this and make something useful.
    // const woot = 'w00t'
    // const decorate = useCallback(
    //   ([node, path]) => {
    //     const ranges: Range[] = []
    //     if (woot && Text.isText(node)) {
    //       const {text} = node
    //       const parts = text.split(woot)
    //       let offset = 0
    //       parts.forEach((part, i) => {
    //         if (i !== 0) {
    //           ranges.push({
    //             anchor: {path, offset: offset - woot.length},
    //             focus: {path, offset},
    //             __highlight: true
    //           })
    //         }
    //         offset = offset + part.length + woot.length
    //       })
    //     }
    //     return ranges
    //   },
    //   [woot]
    // )
    const setValueFromProps = () => {
        if (VALUE_TO_SLATE_VALUE.get(value || []) !== stateValue) {
            debug('Setting value from props');
            const slateValueFromProps = values_1.toSlateValue(value, portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_SLATE_ELEMENT.get(editor));
            setStateValue(slateValueFromProps);
            VALUE_TO_SLATE_VALUE.set(value || [], slateValueFromProps);
            change$.next({ type: 'value', value: value });
        }
        else {
            debug('Value in sync, not updating value from props');
        }
    };
    react_1.useEffect(() => {
        weakMaps_1.KEY_TO_SLATE_ELEMENT.set(editor, {});
        weakMaps_1.KEY_TO_VALUE_ELEMENT.set(editor, {});
        return () => {
            weakMaps_1.KEY_TO_SLATE_ELEMENT.delete(editor);
            weakMaps_1.KEY_TO_VALUE_ELEMENT.delete(editor);
        };
    }, []);
    // Restore value from props
    react_1.useEffect(() => {
        if (isThrottling) {
            debug('Not setting value from props (throttling)');
            return;
        }
        if (isSelecting) {
            debug('Not setting value from props (is selecting)');
            return;
        }
        setValueFromProps();
    }, [value, isSelecting]);
    // Restore selection from props
    react_1.useEffect(() => {
        const pSelection = props.selection;
        if (pSelection && !isThrottling && !lodash_1.isEqual(pSelection, selection_1.toPortableTextRange(editor))) {
            debug('Selection from props', pSelection);
            const normalizedSelection = selection_1.normalizeSelection(pSelection, value);
            if (normalizedSelection !== null) {
                debug('Normalized selection from props', normalizedSelection);
                const slateRange = selection_1.toSlateRange(normalizedSelection, editor);
                setSelection(slateRange);
            }
            else if (stateValue) {
                debug('Selecting top document');
                setSelection(SELECT_TOP_DOCUMENT);
            }
        }
    }, [props.selection]);
    // Handle copy in the editor
    const handleCopy = (event) => {
        const { onCopy } = props;
        if (onCopy) {
            const result = onCopy(event);
            // CopyFn may return something to avoid doing default stuff
            if (result !== undefined) {
                event.preventDefault();
                return;
            }
        }
        if (copyPaste_1.hasEditableTarget(editor, event.target)) {
            // Set Portable Text on the clipboard
            copyPaste_1.setFragmentData(event.clipboardData, editor, portableTextFeatures);
            return editor;
        }
    };
    // Handle pasting in the editor
    const handlePaste = (event) => {
        event.persist(); // Keep the event through the plugin chain after calling next()
        const { onPaste } = props;
        const selection = PortableTextEditor_1.PortableTextEditor.getSelection(portableTextEditor);
        const type = portableTextFeatures.types.portableText;
        if (!selection) {
            return;
        }
        if (onPaste) {
            const resolveOnPasteResultOrError = () => {
                try {
                    return onPaste({ event, value, path: selection.focus.path, type });
                }
                catch (error) {
                    return error;
                }
            };
            // Resolve it as promise (can be either async promise or sync return value)
            const resolved = Promise.resolve(resolveOnPasteResultOrError());
            return resolved
                .then((result) => {
                debug('Custom paste function from client resolved', result);
                change$.next({ type: 'loading', isLoading: true });
                if (!result) {
                    return;
                }
                if (result instanceof Error) {
                    throw result;
                }
                if (typeof result === 'object' && result.insert) {
                    event.preventDefault(); // Stop the chain
                    const allowedDecorators = portableTextFeatures.decorators.map(item => item.value);
                    const blocksToInsertNormalized = result.insert.map(block => block_tools_1.normalizeBlock(block, { allowedDecorators }));
                    const dataTransfer = new DataTransfer();
                    const stringToEncode = JSON.stringify(values_1.toSlateValue(blocksToInsertNormalized, portableTextFeatures.types.block.name));
                    const encoded = window.btoa(encodeURIComponent(stringToEncode));
                    dataTransfer.setData('application/x-slate-fragment', encoded);
                    editor.insertData(dataTransfer);
                    change$.next({ type: 'loading', isLoading: false });
                    editor.onChange();
                    return result;
                }
                console.warn('Your onPaste function returned something unexpected:', result);
                return;
            })
                .catch(error => {
                change$.next({ type: 'loading', isLoading: false });
                console.error(error); // eslint-disable-line no-console
                return error;
            });
        }
    };
    // There's a bug in Slate atm regarding void nodes not being deleted. Seems related
    // to 'hanging: true' and 'voids: false'. 2020/05/26
    const handleCut = (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (editor.selection) {
            slate_react_1.ReactEditor.setFragmentData(editor, event.clipboardData);
            slate_1.Transforms.delete(editor, { at: editor.selection, voids: false, hanging: true });
            slate_1.Transforms.collapse(editor);
            editor.onChange();
        }
        return editor;
    };
    // Set initial selection from props
    react_1.useEffect(() => {
        if (props.selection) {
            PortableTextEditor_1.PortableTextEditor.select(portableTextEditor, props.selection);
        }
    }, []);
    // Emit selection after a selection is made
    const emitSelection = () => {
        try {
            const newSelection = selection_1.toPortableTextRange(editor);
            // debug('Emitting new selection', JSON.stringify(newSelection))
            change$.next({ type: 'selection', selection: newSelection });
        }
        catch (err) {
            change$.next({ type: 'selection', selection: null });
        }
    };
    const handleSelect = () => {
        if (isThrottling) {
            return;
        }
        emitSelection();
    };
    react_1.useEffect(() => {
        if (isThrottling) {
            return;
        }
        emitSelection();
    }, [isThrottling]);
    react_1.useEffect(() => {
        emitSelection();
    }, [selection]);
    // Make sure that when the user is actively selecting something, we don't update the editor or selections will be broken
    let _isSelecting = false;
    const onSelectStart = (event) => {
        if (slate_react_1.ReactEditor.hasDOMNode(editor, event.target)) {
            debug('Start selecting');
            _isSelecting = true;
            setTimeout(() => setIsSelecting(true));
        }
    };
    const onSelectEnd = () => {
        if (_isSelecting) {
            debug('Done selecting');
            setTimeout(() => setIsSelecting(false));
        }
    };
    const isSelectKeys = (event) => is_hotkey_1.default('shift+down', event) ||
        is_hotkey_1.default('shift+up', event) ||
        is_hotkey_1.default('shift+left', event) ||
        is_hotkey_1.default('shift+right', event) ||
        is_hotkey_1.default('shift+end', event) ||
        is_hotkey_1.default('shift+home', event) ||
        is_hotkey_1.default('shift+pageDown', event) ||
        is_hotkey_1.default('shift+pageUp', event);
    let isSelectingWithKeys = false;
    const onSelectStartWithKeys = (event) => {
        if (isSelectKeys(event)) {
            isSelectingWithKeys = true;
            onSelectStart(event);
        }
    };
    const onSelectEndWithKeys = event => {
        if (isSelectingWithKeys && event.key === 'Shift') {
            onSelectEnd();
            isSelectingWithKeys = false;
        }
    };
    react_1.useEffect(() => {
        document.addEventListener('keydown', onSelectStartWithKeys, false);
        document.addEventListener('keyup', onSelectEndWithKeys, false);
        document.addEventListener('mousedown', onSelectStart, false);
        document.addEventListener('mouseup', onSelectEnd, false);
        document.addEventListener('dragend', onSelectEnd, false);
        return () => {
            document.removeEventListener('keydown', onSelectStartWithKeys, false);
            document.removeEventListener('keyup', onSelectEndWithKeys, false);
            document.removeEventListener('mousedown', onSelectStart, false);
            document.removeEventListener('mouseup', onSelectEnd, false);
            document.removeEventListener('dragend', onSelectEnd, false);
        };
    }, []);
    const handleOnFocus = () => {
        change$.next({ type: 'focus' });
    };
    const handleOnBlur = () => {
        change$.next({ type: 'blur' });
    };
    const handleOnBeforeInput = (event) => {
        if (props.onBeforeInput) {
            props.onBeforeInput(event);
        }
    };
    // The editor
    const slateEditable = react_1.useMemo(() => (react_1.default.createElement(slate_react_1.Slate, { onChange: handleChange, editor: editor, selection: selection, value: getValueOrIntitialValue(stateValue, [createPlaceHolderBlock()]) },
        react_1.default.createElement(slate_react_1.Editable, { autoFocus: false, className: 'pt-editable', 
            // decorate={decorate}
            onDOMBeforeInput: handleOnBeforeInput, onBlur: handleOnBlur, onCopy: handleCopy, onCut: handleCut, onFocus: handleOnFocus, onKeyDown: editor.pteWithHotKeys, onPaste: handlePaste, onSelect: handleSelect, placeholder: placeholderText, readOnly: readOnly, renderElement: renderElement, renderLeaf: renderLeaf, spellCheck: spellCheck }))), [placeholderText, readOnly, spellCheck, stateValue, selection]);
    if (!portableTextEditor) {
        return null;
    }
    return slateEditable;
};
function getValueOrIntitialValue(value, initialValue) {
    if (Array.isArray(value) && value.length > 0) {
        return value;
    }
    return initialValue;
}
//# sourceMappingURL=Editable.js.map