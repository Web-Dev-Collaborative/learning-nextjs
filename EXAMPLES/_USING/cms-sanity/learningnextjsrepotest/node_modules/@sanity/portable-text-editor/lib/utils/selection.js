"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toSlateRange = exports.toPortableTextRange = exports.normalizeSelection = exports.createArrayedPath = exports.createKeyedPath = void 0;
const lodash_1 = require("lodash");
const slate_1 = require("slate");
const types_1 = require("@sanity/types");
function createKeyedPath(point, editor) {
    let blockPath = [point.path[0]];
    let block;
    try {
        ;
        [block] = slate_1.Editor.node(editor, blockPath, { depth: 1 });
    }
    catch (err) {
        return null;
    }
    if (!block || !slate_1.Element.isElement(block)) {
        return null;
    }
    const keyedBlockPath = [{ _key: block._key }];
    if (editor.isVoid(block)) {
        return keyedBlockPath;
    }
    let keyedChildPath;
    let child;
    const childPath = point.path.slice(0, 2);
    if (childPath.length === 2) {
        try {
            ;
            [child] = slate_1.Editor.node(editor, childPath, { depth: 2 });
        }
        catch (err) {
            return null;
        }
        keyedChildPath = ['children', { _key: child._key }];
    }
    return keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;
}
exports.createKeyedPath = createKeyedPath;
function createArrayedPath(point, editor) {
    if (!editor) {
        return [];
    }
    const [block, blockPath] = Array.from(slate_1.Editor.nodes(editor, {
        at: [],
        match: n => types_1.isKeySegment(point.path[0]) && n._key === point.path[0]._key
    }))[0] || [undefined, undefined];
    if (!block || !slate_1.Element.isElement(block)) {
        return [];
    }
    if (editor.isVoid(block)) {
        return blockPath;
    }
    const childPath = [point.path[2]];
    const childIndex = block.children.findIndex(child => lodash_1.isEqual([{ _key: child._key }], childPath));
    if (childIndex >= 0 && block.children[childIndex]) {
        const child = block.children[childIndex];
        if (slate_1.Element.isElement(child) && editor.isVoid(child)) {
            return blockPath.concat(childIndex).concat(0);
        }
        return blockPath.concat(childIndex);
    }
    return blockPath;
}
exports.createArrayedPath = createArrayedPath;
function normalizePoint(point, value) {
    if (!point || !value) {
        return null;
    }
    const newPath = [];
    let newOffset = point.offset || 0;
    const block = value.find(blk => blk._key === point.path[0]['_key']);
    if (block) {
        newPath.push({ _key: block._key });
    }
    else {
        return null;
    }
    if (block && point.path[1] === 'children') {
        if (!block.children || block.children.length === 0) {
            return null;
        }
        const child = block.children.find(cld => cld._key === point.path[2]['_key']);
        if (child) {
            newPath.push('children');
            newPath.push({ _key: child._key });
            newOffset =
                child.text && child.text.length >= point.offset
                    ? point.offset
                    : (child.text && child.text.length) || 0;
        }
        else {
            return null;
        }
    }
    return { path: newPath, offset: newOffset };
}
function normalizeSelection(selection, value) {
    if (!selection || !value || value.length === 0) {
        return null;
    }
    let newAnchor = null;
    let newFocus = null;
    const { anchor, focus } = selection;
    if (anchor && value.find(blk => lodash_1.isEqual({ _key: blk._key }, anchor.path[0]))) {
        newAnchor = normalizePoint(anchor, value);
    }
    if (focus && value.find(blk => lodash_1.isEqual({ _key: blk._key }, focus.path[0]))) {
        newFocus = normalizePoint(focus, value);
    }
    if (newAnchor && newFocus) {
        return { anchor: newAnchor, focus: newFocus };
    }
    return null;
}
exports.normalizeSelection = normalizeSelection;
function toPortableTextRange(editor) {
    if (!editor.selection) {
        return editor.selection;
    }
    let anchor;
    let focus;
    const anchorPath = createKeyedPath(editor.selection.anchor, editor);
    if (anchorPath) {
        anchor = {
            path: createKeyedPath(editor.selection.anchor, editor),
            offset: editor.selection.anchor.offset
        };
    }
    const focusPath = createKeyedPath(editor.selection.focus, editor);
    if (focusPath) {
        focus = {
            path: createKeyedPath(editor.selection.focus, editor),
            offset: editor.selection.focus.offset
        };
    }
    const range = anchor && focus ? { anchor, focus } : null;
    return range;
}
exports.toPortableTextRange = toPortableTextRange;
function toSlateRange(selection, editor) {
    if (!selection || !editor) {
        return null;
    }
    const anchor = {
        path: createArrayedPath(selection.anchor, editor),
        offset: selection.anchor.offset
    };
    const focus = {
        path: createArrayedPath(selection.focus, editor),
        offset: selection.focus.offset
    };
    const range = anchor && focus ? { anchor, focus } : null;
    return range;
}
exports.toSlateRange = toSlateRange;
//# sourceMappingURL=selection.js.map