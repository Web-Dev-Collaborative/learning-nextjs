"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPatchToOperations = void 0;
const slate_1 = require("slate");
const values_1 = require("./values");
const debug_1 = require("./debug");
const weakMaps_1 = require("./weakMaps");
const debug = debug_1.debugWithName('operationToPatches');
function createPatchToOperations(portableTextFeatures) {
    function insertPatch(editor, patch) {
        if (patch.path.length === 1) {
            const { items, position } = patch;
            const blocksToInsert = values_1.toSlateValue(items, portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_SLATE_ELEMENT.get(editor));
            const posKey = findLastKey(patch.path);
            let index = editor.children.findIndex((node, indx) => {
                return posKey ? node._key === posKey : indx === patch.path[0];
            });
            const normalizedIdx = position === 'after' ? index + 1 : index;
            debug(`Inserting blocks at path [${normalizedIdx}]`);
            slate_1.Transforms.insertNodes(editor, blocksToInsert, { at: [normalizedIdx] });
            return true;
        }
        return false;
    }
    function unsetPatch(editor, patch) {
        // Deal with patches unsetting the whole field
        if (patch.path.length === 0) {
            debug(`Removing everything`);
            editor.children = [];
            return true;
        }
        if (patch.path.length === 1) {
            const lastKey = findLastKey(patch.path);
            let index = editor.children.findIndex((node, indx) => lastKey ? node._key === lastKey : indx === patch.path[0]);
            if (index > -1) {
                slate_1.Transforms.removeNodes(editor, { at: [index] });
                debug(`Removing block at path [${index}]`);
            }
            return true;
        }
        return false;
    }
    return function (editor, patch) {
        switch (patch.type) {
            case 'insert':
                return !!insertPatch(editor, patch);
            case 'unset':
                return !!unsetPatch(editor, patch);
            default:
                debug('Unhandled patch', patch.type);
        }
        return false;
    };
}
exports.createPatchToOperations = createPatchToOperations;
function isKeyedSegment(segment) {
    return typeof segment === 'object' && '_key' in segment;
}
// Helper function to find the last part of a patch path that has a known key
function findLastKey(path) {
    let key = null;
    path.forEach(part => {
        if (isKeyedSegment(part)) {
            key = part._key;
        }
    });
    return key;
}
//# sourceMappingURL=patchToOperations.js.map