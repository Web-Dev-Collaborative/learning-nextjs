"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortableTextEditor = exports.defaultKeyGenerator = void 0;
const react_1 = __importDefault(require("react"));
const randomKey_1 = require("../utils/randomKey");
const schema_1 = require("../utils/schema");
const getPortableTextFeatures_1 = require("../utils/getPortableTextFeatures");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const usePortableTextEditor_1 = require("./hooks/usePortableTextEditor");
const usePortableTextEditorSelection_1 = require("./hooks/usePortableTextEditorSelection");
const usePortableTextEditorValue_1 = require("./hooks/usePortableTextEditorValue");
const patches_1 = require("../utils/patches");
const validateValue_1 = require("../utils/validateValue");
const debug_1 = require("../utils/debug");
exports.defaultKeyGenerator = () => randomKey_1.randomKey(12);
const debug = debug_1.debugWithName('component:PortableTextEditor');
// The PT editor's public API
class PortableTextEditor extends react_1.default.Component {
    constructor(props) {
        super(props);
        this.pendingPatches = [];
        this.change$ = new rxjs_1.Subject();
        this.isThrottling = false;
        this.setEditable = editable => {
            this.editable = Object.assign(Object.assign({}, this.editable), editable);
            this.change$.next({ type: 'ready' });
        };
        this.flush = () => {
            const { onChange } = this.props;
            const finalPatches = patches_1.compactPatches(this.pendingPatches);
            if (finalPatches.length > 0) {
                onChange({ type: 'mutation', patches: finalPatches });
            }
            this.pendingPatches = [];
        };
        this.onEditorChange = (next) => {
            const { onChange } = this.props;
            switch (next.type) {
                case 'mutation':
                    if (!this.isThrottling) {
                        this.flush();
                    }
                    else {
                        this.pendingPatches = [...this.pendingPatches, ...next.patches];
                    }
                    break;
                case 'throttle':
                    if (next.throttle) {
                        this.isThrottling = true;
                    }
                    else {
                        this.isThrottling = false;
                        if (this.pendingPatches.length > 0) {
                            this.flush();
                        }
                    }
                    break;
                case 'selection':
                    this.setState({ selection: next.selection });
                    break;
                case 'undo':
                case 'redo':
                    this.flush();
                    onChange(next);
                    break;
                default:
                    onChange(next);
            }
        };
        // Test if we have a compiled schema type, if not, conveniently compile it
        this.type = props.type;
        if (!props.type.hasOwnProperty('jsonType')) {
            this.type = schema_1.compileType(props.type);
        }
        // Indicate that we are loading
        this.change$.next({ type: 'loading', isLoading: true });
        // Get the block types feature set (lookup table)
        this.portableTextFeatures = getPortableTextFeatures_1.getPortableTextFeatures(this.type);
        // Subscribe to (distinct) changes
        this.changeSubscription = this.change$
            .pipe(operators_1.distinctUntilChanged())
            .subscribe(this.onEditorChange);
        // Setup keyGenerator (either from props, or default)
        this.keyGenerator = props.keyGenerator || exports.defaultKeyGenerator;
        // Validate the Portable Text value
        let state = { selection: null, invalidValueResolution: null };
        const validation = validateValue_1.validateValue(props.value, this.portableTextFeatures, this.keyGenerator);
        if (props.value && !validation.valid) {
            this.change$.next({ type: 'loading', isLoading: false });
            this.change$.next({
                type: 'invalidValue',
                resolution: validation.resolution,
                value: props.value
            });
            state = Object.assign(Object.assign({}, state), { invalidValueResolution: validation.resolution });
        }
        this.incomingPatche$ = props.incomingPatche$;
        this.maxBlocks =
            typeof props.maxBlocks === 'undefined'
                ? undefined
                : parseInt(props.maxBlocks.toString(), 10) || undefined;
        this.readOnly = props.readOnly || false;
        this.state = state;
    }
    componentWillUnmount() {
        this.flush();
        this.changeSubscription.unsubscribe();
    }
    componentDidUpdate(prevProps) {
        this.readOnly = this.props.readOnly || false;
        // Validate again if value length has changed
        if (this.props.value && (prevProps.value || []).length !== this.props.value.length) {
            debug('Validating');
            const validation = validateValue_1.validateValue(this.props.value, this.portableTextFeatures, this.keyGenerator);
            if (this.props.value && !validation.valid) {
                this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: this.props.value
                });
                this.setState({ invalidValueResolution: validation.resolution });
            }
        }
    }
    render() {
        if (this.state.invalidValueResolution) {
            return this.state.invalidValueResolution.description;
        }
        return (react_1.default.createElement(usePortableTextEditor_1.PortableTextEditorContext.Provider, { value: this },
            react_1.default.createElement(usePortableTextEditorValue_1.PortableTextEditorValueContext.Provider, { value: this.props.value },
                react_1.default.createElement(usePortableTextEditorSelection_1.PortableTextEditorSelectionContext.Provider, { value: this.state.selection }, this.props.children))));
    }
}
exports.PortableTextEditor = PortableTextEditor;
PortableTextEditor.activeAnnotations = (editor) => {
    return editor && editor.editable ? editor.editable.activeAnnotations() : [];
};
PortableTextEditor.addAnnotation = (editor, type, value) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.addAnnotation(type, value); };
PortableTextEditor.blur = (editor) => {
    var _a;
    debug('Host blurred');
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.blur();
};
PortableTextEditor.delete = (editor, selection, options) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.delete(selection, options); };
PortableTextEditor.findDOMNode = (editor, element) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findDOMNode(element);
};
PortableTextEditor.findByPath = (editor, path) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findByPath(path);
};
PortableTextEditor.focus = (editor) => {
    var _a;
    debug('Host requesting focus');
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focus();
};
PortableTextEditor.focusBlock = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusBlock();
};
PortableTextEditor.focusChild = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusChild();
};
PortableTextEditor.getPortableTextFeatures = (editor) => {
    return editor.portableTextFeatures;
};
PortableTextEditor.getSelection = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.getSelection();
};
PortableTextEditor.getValue = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.getValue();
};
PortableTextEditor.hasBlockStyle = (editor, blockStyle) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasBlockStyle(blockStyle);
};
PortableTextEditor.hasListStyle = (editor, listStyle) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasListStyle(listStyle);
};
PortableTextEditor.isCollapsedSelection = (editor) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isCollapsedSelection(); };
PortableTextEditor.isExpandedSelection = (editor) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isExpandedSelection(); };
PortableTextEditor.isMarkActive = (editor, mark) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isMarkActive(mark); };
PortableTextEditor.insertChild = (editor, type, value) => {
    var _a;
    debug(`Host inserting child`);
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertChild(type, value);
};
PortableTextEditor.insertBlock = (editor, type, value) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertBlock(type, value);
};
PortableTextEditor.isVoid = (editor, element) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isVoid(element);
};
PortableTextEditor.marks = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.marks();
};
PortableTextEditor.select = (editor, selection) => {
    var _a;
    debug(`Host setting selection`, selection);
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.select(selection);
};
PortableTextEditor.removeAnnotation = (editor, type) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.removeAnnotation(type); };
PortableTextEditor.toggleBlockStyle = (editor, blockStyle) => {
    var _a;
    debug(`Host is toggling block style`);
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleBlockStyle(blockStyle);
};
PortableTextEditor.toggleList = (editor, listStyle) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleList(listStyle);
};
PortableTextEditor.toggleMark = (editor, mark) => {
    var _a;
    debug(`Host toggling mark`, mark);
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleMark(mark);
};
//# sourceMappingURL=PortableTextEditor.js.map