"use strict";
/**
 * This plugin will make the editor support undo/redo on the local state only.
 * The undo/redo steps are rebased against incoming patches since the step occured.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithUndoRedo = void 0;
const lodash_1 = require("lodash");
const slate_1 = require("slate");
const DMP = __importStar(require("diff-match-patch"));
const debug_1 = require("../../utils/debug");
const withoutPatching_1 = require("../../utils/withoutPatching");
const debug = debug_1.debugWithName('plugin:withUndoRedo');
const dmp = new DMP.diff_match_patch();
const SAVING = new WeakMap();
const MERGING = new WeakMap();
const UNDO_STEP_LIMIT = 300;
const isMerging = (editor) => {
    return MERGING.get(editor);
};
const isSaving = (editor) => {
    if (!withoutPatching_1.isPatching(editor)) {
        return false;
    }
    return SAVING.get(editor);
};
function createWithUndoRedo(incomingPatche$) {
    // Subscribe to incoming patches
    const incomingPatches = [];
    if (incomingPatche$) {
        incomingPatche$.subscribe(patch => {
            incomingPatches.push({ patch: patch, time: new Date() });
        });
    }
    return (editor) => {
        editor.history = { undos: [], redos: [] };
        const { apply } = editor;
        // Apply function for merging and saving local history inspired from 'slate-history' by Ian Storm Taylor
        editor.apply = (op) => {
            const { operations, history } = editor;
            const { undos } = history;
            const step = undos[undos.length - 1];
            const lastOp = step && step.operations && step.operations[step.operations.length - 1];
            const overwrite = shouldOverwrite(op, lastOp);
            let save = isSaving(editor);
            let merge = isMerging(editor);
            if (save == null) {
                save = shouldSave(op, lastOp);
            }
            if (save) {
                if (merge == null) {
                    if (step == null) {
                        merge = false;
                    }
                    else if (operations.length !== 0) {
                        merge = true;
                    }
                    else {
                        merge = shouldMerge(op, lastOp) || overwrite;
                    }
                }
                if (step && merge) {
                    if (overwrite) {
                        step.operations.pop();
                    }
                    step.operations.push(op);
                }
                else {
                    const operations = [
                        ...(editor.selection !== null ? [createSelectOperation(editor)] : []),
                        op
                    ];
                    const step = {
                        operations,
                        timestamp: new Date()
                    };
                    undos.push(step);
                    debug('Created new undo step', step);
                }
                while (undos.length > UNDO_STEP_LIMIT) {
                    undos.shift();
                }
                if (shouldClear(op)) {
                    history.redos = [];
                }
            }
            apply(op);
        };
        editor.undo = () => {
            const { undos } = editor.history;
            if (undos.length > 0) {
                const step = undos[undos.length - 1];
                debug('Undoing', step);
                if (step.operations.length > 0) {
                    const otherPatches = [...incomingPatches.filter(item => item.time > step.timestamp)];
                    let transformedOperations = step.operations;
                    otherPatches.forEach(item => {
                        transformedOperations = lodash_1.flatten(transformedOperations.map(op => transformOperation(editor, item.patch, op)));
                    });
                    withoutSaving(editor, () => {
                        slate_1.Editor.withoutNormalizing(editor, () => {
                            transformedOperations
                                .map(slate_1.Operation.inverse)
                                .reverse()
                                .forEach(op => {
                                // TODO: stop trying this, and have a perfect transformation!
                                try {
                                    editor.apply(op);
                                }
                                catch (err) {
                                    debug('Could not perform undo step', err);
                                    editor.history.redos.push(step);
                                    editor.history.undos.pop();
                                    return;
                                }
                            });
                        });
                    });
                }
                editor.history.redos.push(step);
                editor.history.undos.pop();
                editor.onChange();
            }
        };
        editor.redo = () => {
            const { redos } = editor.history;
            if (redos.length > 0) {
                const step = redos[redos.length - 1];
                debug('Redoing', step);
                if (step.operations.length > 0) {
                    const otherPatches = incomingPatches.filter(item => item.time > step.timestamp);
                    let transformedOperations = step.operations;
                    otherPatches.forEach(item => {
                        transformedOperations = lodash_1.flatten(transformedOperations.map(op => transformOperation(editor, item.patch, op)));
                    });
                    withoutSaving(editor, () => {
                        slate_1.Editor.withoutNormalizing(editor, () => {
                            transformedOperations.forEach(op => {
                                try {
                                    editor.apply(op);
                                }
                                catch (err) {
                                    debug('Could not perform redo step', err);
                                    editor.history.undos.push(step);
                                    editor.history.redos.pop();
                                    return;
                                }
                            });
                        });
                    });
                }
                editor.history.undos.push(step);
                editor.history.redos.pop();
                editor.onChange();
            }
        };
        // Plugin return
        return editor;
    };
}
exports.createWithUndoRedo = createWithUndoRedo;
// This will adjust the user selection according to patcehes done by others.
// TODO: complete all necessary steps of the algorithm and write tests.
function transformOperation(editor, patch, operation) {
    // debug(`Rebasing selection for patch ${patch.type} against operation ${operation.type}`)
    let transformedOperation = Object.assign({}, operation);
    if (patch.type === 'insert' && patch.path.length === 1) {
        return [adjustBlockPath(editor, patch, operation, patch.items.length)];
    }
    if (patch.type === 'unset' && patch.path.length === 1) {
        return [adjustBlockPath(editor, patch, operation, -1)];
    }
    // Someone reset the whole value
    if (patch.type === 'unset' && patch.path.length === 0) {
        debug(`Adjusting selection for unset everything patch and ${operation.type} operation`);
        return [];
    }
    if (patch.type === 'diffMatchPatch') {
        let blockIndex = editor.children.findIndex(blk => lodash_1.isEqual({ _key: blk._key }, patch.path[0]));
        const block = editor.children[blockIndex];
        if (block && Array.isArray(block.children)) {
            const childIndex = block.children.findIndex(child => lodash_1.isEqual({ _key: child._key }, patch.path[2]));
            const parsed = dmp.patch_fromText(patch.value)[0];
            if (!parsed) {
                debug('Could not parse diffMatchPatch', patch);
                return [operation];
            }
            const distance = parsed.length2 - parsed.length1;
            const patchIsRemovingText = parsed.diffs.some(diff => diff[0] === -1);
            if (operation.type === 'split_node' && operation.path.length > 1) {
                const splitOperation = transformedOperation;
                if (patchIsRemovingText) {
                    splitOperation.position = splitOperation.position - distance;
                }
                else {
                    splitOperation.position = splitOperation.position + distance;
                }
                return [splitOperation];
            }
            if (slate_1.Path.isPath(operation.path) &&
                operation.path[0] !== undefined &&
                operation.path[0] === blockIndex &&
                operation.path[1] === childIndex) {
                if (operation.type === 'insert_text') {
                    let insertOffset = 0;
                    for (const diff of parsed.diffs) {
                        if (diff[0] === 0) {
                            insertOffset = diff[1].length;
                        }
                        if (diff[0] === 1) {
                            break;
                        }
                    }
                    if (insertOffset + parsed.start1 <= operation.offset) {
                        const insertTextOperation = transformedOperation;
                        insertTextOperation.offset = insertTextOperation.offset + distance;
                        transformedOperation = insertTextOperation;
                    }
                    // TODO: deal with overlapping ranges
                    return [transformedOperation];
                }
                if (operation.type === 'remove_text') {
                    let insertOffset = 0;
                    for (const diff of parsed.diffs) {
                        if (diff[0] === 0) {
                            insertOffset = diff[1].length;
                        }
                        if (diff[0] === -1) {
                            break;
                        }
                    }
                    if (insertOffset + parsed.start1 <= operation.offset) {
                        const removeTextOperation = transformedOperation;
                        removeTextOperation.offset = removeTextOperation.offset - distance;
                        transformedOperation = removeTextOperation;
                    }
                    return [transformedOperation];
                }
            }
            // // Selection operations with diffPatchMatch
            // if (operation.type === 'set_selection') {
            //   const newProperties = transformedOperation.newProperties
            //   if (newProperties && patchIsRemovingText) {
            //     newProperties.offset = newProperties.offset - distance
            //   } else if (newProperties) {
            //     newProperties.offset = newProperties.offset + distance
            //   }
            //   return [newProperties ? {...transformedOperation, newProperties} : transformedOperation]
            // }
        }
        // TODO: transform this?
        // if (operation.type === 'set_selection' && patch.type !== 'diffMatchPatch') {
        //   console.log('set_selection other', JSON.stringify(patch))
        // }
    }
    return [operation];
}
function adjustBlockPath(editor, patch, operation, level) {
    const transformedOperation = Object.assign({}, operation);
    const myIndex = editor.children.findIndex(blk => lodash_1.isEqual({ _key: blk._key }, patch.path[0]));
    if (myIndex >= 0 &&
        operation.path &&
        operation.path[0] !== undefined &&
        operation.path[0] >= myIndex + level) {
        const newPath = [operation.path[0] + level, ...operation.path.slice(1)];
        debug(`Adjusting ${operation.type} for block ${patch.type}`, operation.path, newPath);
        transformedOperation.path = newPath;
    }
    return transformedOperation;
}
// Helper functions for editor.apply above
const shouldMerge = (op, prev) => {
    if (op.type === 'set_selection') {
        return true;
    }
    // Text input
    if (prev &&
        op.type === 'insert_text' &&
        prev.type === 'insert_text' &&
        op.offset === prev.offset + prev.text.length &&
        slate_1.Path.equals(op.path, prev.path) &&
        op.text !== ' ' // Tokenize between words
    ) {
        return true;
    }
    // Text deletion
    if (prev &&
        op.type === 'remove_text' &&
        prev.type === 'remove_text' &&
        op.offset + op.text.length === prev.offset &&
        slate_1.Path.equals(op.path, prev.path)) {
        return true;
    }
    // Don't merge
    return false;
};
const shouldSave = (op, prev) => {
    if (op.type === 'set_selection' && op.newProperties === null) {
        return false;
    }
    return true;
};
const shouldOverwrite = (op, prev) => {
    if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {
        return true;
    }
    return false;
};
const shouldClear = (op) => {
    if (op.type === 'set_selection') {
        return false;
    }
    return true;
};
function withoutSaving(editor, fn) {
    const prev = isSaving(editor);
    SAVING.set(editor, false);
    fn();
    SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
    return {
        type: 'set_selection',
        properties: Object.assign({}, editor.selection),
        newProperties: Object.assign({}, editor.selection)
    };
}
//# sourceMappingURL=createWithUndoRedo.js.map