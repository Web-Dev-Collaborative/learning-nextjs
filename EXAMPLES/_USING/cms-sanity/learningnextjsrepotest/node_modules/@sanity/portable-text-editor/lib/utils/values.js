"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findChildAndIndexFromPath = exports.findBlockAndIndexFromPath = exports.isEqualToEmptyEditor = exports.fromSlateValue = exports.toSlateValue = void 0;
const lodash_1 = require("lodash");
const slate_1 = require("slate");
function keepObjectEquality(object, keyMap) {
    const value = keyMap[object._key];
    if (value && lodash_1.isEqual(object, value)) {
        return value;
    }
    keyMap[object._key] = object;
    return object;
}
function toSlateValue(value, textBlockType, keyMap = {}) {
    if (value && Array.isArray(value)) {
        return value.map(block => {
            const { _type, _key } = block, rest = __rest(block, ["_type", "_key"]);
            const isPortableText = block && block._type === textBlockType;
            if (isPortableText) {
                let hasInlines = false;
                const children = block.children.map(child => {
                    const { _type, _key } = child, rest = __rest(child, ["_type", "_key"]);
                    if (_type !== 'span') {
                        hasInlines = true;
                        return keepObjectEquality({ _type, _key, children: [{ text: '' }], value: rest, __inline: true }, keyMap);
                    }
                    else {
                        // Original object
                        return child;
                    }
                });
                if (!hasInlines && slate_1.Element.isElement(block)) {
                    // Original object
                    return block;
                }
                return keepObjectEquality(Object.assign(Object.assign({ _type, _key }, rest), { children }), keyMap);
            }
            return keepObjectEquality({ _type, _key, children: [{ text: '' }], value: rest }, keyMap);
        });
    }
    return [];
}
exports.toSlateValue = toSlateValue;
function fromSlateValue(value, textBlockType, keyMap = {}) {
    if (value && Array.isArray(value)) {
        return value.map(block => {
            const isPortableText = block && block._type === textBlockType;
            if (isPortableText && slate_1.Element.isElement(block)) {
                let hasInlines = false;
                const children = block.children.map(child => {
                    const { _type } = child;
                    if (_type !== 'span' && typeof child.value === 'object') {
                        hasInlines = true;
                        const { value, children, __inline } = child, rest = __rest(child, ["value", "children", "__inline"]);
                        return keepObjectEquality(Object.assign(Object.assign({}, rest), value), keyMap);
                    }
                    else {
                        return child;
                    }
                });
                if (typeof block._key === 'string' && typeof block._type === 'string') {
                    if (!hasInlines) {
                        // Original object
                        return block;
                    }
                    return keepObjectEquality(Object.assign(Object.assign({ _key: block._key, _type: block._type }, block), { children }), keyMap);
                }
                throw new Error('Not a valid block type');
            }
            const { _key, _type } = block;
            const value = block.value;
            return keepObjectEquality(Object.assign({ _key, _type }, (typeof value === 'object' ? value : {})), keyMap);
        });
    }
    return value;
}
exports.fromSlateValue = fromSlateValue;
function isEqualToEmptyEditor(children, portableTextFeatures) {
    return (children === undefined ||
        (children && Array.isArray(children) && children.length === 0) ||
        (children &&
            Array.isArray(children) &&
            children.length === 1 &&
            children[0]._type === portableTextFeatures.types.block.name &&
            children[0].children &&
            children[0].children.length === 1 &&
            children[0].children[0]._type === 'span' &&
            children[0].children[0].text === ''));
}
exports.isEqualToEmptyEditor = isEqualToEmptyEditor;
function findBlockAndIndexFromPath(firstPathSegment, children) {
    let blockIndex = -1;
    const isNumber = Number.isInteger(Number(firstPathSegment));
    if (isNumber) {
        blockIndex = Number(firstPathSegment);
    }
    else if (children) {
        blockIndex = children.findIndex(blk => lodash_1.isEqual({ _key: blk._key }, firstPathSegment));
    }
    if (blockIndex > -1) {
        return [children[blockIndex], blockIndex];
    }
    return [undefined, -1];
}
exports.findBlockAndIndexFromPath = findBlockAndIndexFromPath;
function findChildAndIndexFromPath(secondPathSegment, block) {
    let childIndex = -1;
    const isNumber = Number.isInteger(Number(secondPathSegment));
    if (isNumber) {
        childIndex = Number(secondPathSegment);
    }
    else {
        childIndex = block.children.findIndex(child => lodash_1.isEqual({ _key: child._key }, secondPathSegment));
    }
    if (childIndex > -1) {
        return [block.children[childIndex], childIndex];
    }
    return [undefined, -1];
}
exports.findChildAndIndexFromPath = findChildAndIndexFromPath;
//# sourceMappingURL=values.js.map