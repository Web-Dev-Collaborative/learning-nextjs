"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithPortableTextBlockStyle = void 0;
const slate_1 = require("slate");
const debug_1 = require("../../utils/debug");
const selection_1 = require("../../utils/selection");
const debug = debug_1.debugWithName('plugin:withPortableTextBlockStyle');
function createWithPortableTextBlockStyle(portableTextFeatures, change$) {
    return function withPortableTextBlockStyle(editor) {
        const normalStyle = portableTextFeatures.styles[0].value;
        // Extend Slate's default normalization to reset split node to normal style
        // if there is no text at the right end of the split.
        const { normalizeNode } = editor;
        editor.normalizeNode = nodeEntry => {
            normalizeNode(nodeEntry);
            const [, path] = nodeEntry;
            for (const op of editor.operations) {
                if (op.type === 'split_node' &&
                    op.path.length === 1 &&
                    op.properties.style !== normalStyle &&
                    op.path[0] === path[0] &&
                    !slate_1.Path.equals(path, op.path)) {
                    const [child] = slate_1.Editor.node(editor, [op.path[0] + 1, 0]);
                    if (child.text === '') {
                        debug(`Normalizing split node to ${normalStyle} style`, op);
                        slate_1.Transforms.setNodes(editor, { style: normalStyle }, { at: [op.path[0] + 1], voids: false });
                        break;
                    }
                }
            }
        };
        editor.pteHasBlockStyle = (style) => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...slate_1.Editor.nodes(editor, {
                    at: editor.selection,
                    match: node => slate_1.Element.isElement(node) && node.style === style
                })
            ];
            if (selectedBlocks.length > 0) {
                return true;
            }
            return false;
        };
        editor.pteToggleBlockStyle = (blockStyle) => {
            if (!editor.selection) {
                return;
            }
            const selectedBlocks = [
                ...slate_1.Editor.nodes(editor, {
                    at: editor.selection,
                    match: node => slate_1.Element.isElement(node) && node._type === portableTextFeatures.types.block.name
                })
            ];
            selectedBlocks.forEach(([node, path]) => {
                const { style } = node, rest = __rest(node, ["style"]);
                if (node.style === blockStyle) {
                    debug(`Unsetting block style '${blockStyle}'`);
                    slate_1.Transforms.setNodes(editor, Object.assign(Object.assign({}, rest), { style: undefined }), { at: path });
                }
                else {
                    const defaultStyle = portableTextFeatures.styles[0] && portableTextFeatures.styles[0].value;
                    if (blockStyle) {
                        debug(`Setting style '${blockStyle}'`);
                    }
                    else {
                        debug('Setting default style', defaultStyle);
                    }
                    slate_1.Transforms.setNodes(editor, Object.assign(Object.assign({}, rest), { style: blockStyle || defaultStyle }), { at: path });
                }
            });
            // Emit a new selection here (though it might be the same).
            // Toolbars and similar on the outside may rely on selection changes to update themselves.
            change$.next({ type: 'selection', selection: selection_1.toPortableTextRange(editor) });
            editor.onChange();
        };
        return editor;
    };
}
exports.createWithPortableTextBlockStyle = createWithPortableTextBlockStyle;
//# sourceMappingURL=createWithPortableTextBlockStyle.js.map