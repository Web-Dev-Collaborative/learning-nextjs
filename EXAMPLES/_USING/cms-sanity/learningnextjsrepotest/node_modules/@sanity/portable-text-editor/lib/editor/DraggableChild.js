"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DraggableChild = void 0;
const react_1 = __importStar(require("react"));
const slate_1 = require("slate");
const slate_react_1 = require("@sanity/slate-react");
const debug_1 = require("../utils/debug");
const weakMaps_1 = require("../utils/weakMaps");
const debug = debug_1.debugWithName('components:DraggableChild');
const debugRenders = false;
exports.DraggableChild = ({ children, element, readOnly, spanType, keyGenerator }) => {
    const editor = slate_react_1.useEditor();
    const dragGhostRef = react_1.useRef();
    const isInline = react_1.useMemo(() => slate_1.Editor.isInline(editor, element), []);
    const isVoid = react_1.useMemo(() => slate_1.Editor.isVoid(editor, element), []);
    const isSpan = element._type === spanType;
    debugRenders && debug('render');
    if (readOnly && !(isSpan || isInline)) {
        return react_1.default.createElement(react_1.default.Fragment, null, children);
    }
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    const handleDragOver = event => {
        const isMyDragOver = weakMaps_1.IS_DRAGGING_CHILD_ELEMENT.get(editor);
        if (!isMyDragOver) {
            return;
        }
        debug('handle drag over');
        event.preventDefault(); // Needed to get the dropEffect showing
        event.dataTransfer.dropEffect = 'move';
        let domRange;
        const { document } = window;
        const { clientX: x, clientY: y } = event;
        // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2020-05-14)
        if (document.caretRangeFromPoint) {
            domRange = document.caretRangeFromPoint(x, y);
        }
        else {
            const position = document.caretPositionFromPoint(x, y);
            if (position) {
                domRange = document.createRange();
                domRange.setStart(position.offsetNode, position.offset);
                domRange.setEnd(position.offsetNode, position.offset);
            }
        }
        if (!domRange) {
            throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`);
        }
        // Resolve a Slate range from the DOM range.
        const range = slate_react_1.ReactEditor.toSlateRange(editor, domRange);
        if (range) {
            weakMaps_1.IS_DRAGGING_ELEMENT_RANGE.set(editor, range);
            slate_1.Transforms.select(editor, range);
        }
    };
    // Note: this is called for the dragging child
    const handleDragEnd = event => {
        weakMaps_1.IS_DRAGGING.set(editor, false);
        event.preventDefault();
        event.stopPropagation();
        if (dragGhostRef.current) {
            debug('Removing drag ghost');
            document.body.removeChild(dragGhostRef.current);
        }
        const range = weakMaps_1.IS_DRAGGING_ELEMENT_RANGE.get(editor);
        if (range && editor.selection) {
            debug('Removing and inserting');
            const dupedElement = Object.assign(Object.assign({}, element), { _key: keyGenerator() });
            slate_1.Transforms.insertNodes(editor, dupedElement, { at: range, select: true });
            slate_1.Transforms.removeNodes(editor, {
                at: [],
                match: n => n._key === element._key,
                mode: 'lowest'
            });
            editor.onChange();
        }
        weakMaps_1.IS_DRAGGING_ELEMENT_RANGE.delete(editor);
        weakMaps_1.IS_DRAGGING_CHILD_ELEMENT.delete(editor);
    };
    // Note: this is called for the dragging child
    const handleDragStart = event => {
        debug('Drag start');
        if (!isVoid) {
            debug('Not dragging child');
            weakMaps_1.IS_DRAGGING.set(editor, false);
            return;
        }
        event.dataTransfer.effectAllowed = 'move';
        weakMaps_1.IS_DRAGGING.set(editor, true);
        weakMaps_1.IS_DRAGGING_CHILD_ELEMENT.set(editor, element);
        // Specify dragImage so that single elements in the preview will not be the drag image,
        // but always the whole block preview itself.
        // Also clone it so that it will not be visually clipped by scroll-containers etc.
        const elm = event.currentTarget;
        if (elm && elm instanceof HTMLElement) {
            const dragGhost = elm.cloneNode(true);
            dragGhostRef.current = dragGhost;
            dragGhost.style.width = `${elm.clientWidth}px`;
            dragGhost.style.height = `${elm.clientHeight}px`;
            dragGhost.style.position = 'absolute';
            dragGhost.style.top = '-99999px';
            dragGhost.style.left = '-99999px';
            if (document.body) {
                document.body.appendChild(dragGhost);
                const rect = elm.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                dragGhost.style.width = `${rect.width}px`;
                dragGhost.style.height = `${rect.height}px`;
                event.dataTransfer.setDragImage(dragGhost, x, y);
            }
        }
    };
    if (isSpan) {
        return react_1.default.createElement("span", { onDragOver: handleDragOver }, children);
    }
    const stopEventIfVoid = event => {
        if (isVoid) {
            event.stopPropagation();
            event.preventDefault();
        }
    };
    return (react_1.default.createElement("span", { draggable: isVoid, onDragStart: handleDragStart, onDragOver: handleDragOver, onDragEnd: handleDragEnd, onDrop: stopEventIfVoid }, children));
};
//# sourceMappingURL=DraggableChild.js.map