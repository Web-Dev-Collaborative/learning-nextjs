"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithPatches = void 0;
const DMP = __importStar(require("diff-match-patch"));
const lodash_1 = require("lodash");
const slate_1 = require("slate");
const PatchEvent_1 = require("../../patch/PatchEvent");
const PatchEvent_2 = require("./../../patch/PatchEvent");
const values_1 = require("../../utils/values");
const debug_1 = require("../../utils/debug");
const patchToOperations_1 = require("../../utils/patchToOperations");
const withoutPatching_1 = require("../../utils/withoutPatching");
const weakMaps_1 = require("../../utils/weakMaps");
const debug = debug_1.debugWithName('plugin:withPatches');
const dmp = new DMP.diff_match_patch();
const THROTTLE_EDITOR_MS = 500;
function createWithPatches({ insertNodePatch, insertTextPatch, mergeNodePatch, moveNodePatch, removeNodePatch, removeTextPatch, setNodePatch, splitNodePatch }, change$, portableTextFeatures, incomingPatche$) {
    const patchToOperations = patchToOperations_1.createPatchToOperations(portableTextFeatures);
    let previousChildren;
    let isThrottling = false;
    return function withPatches(editor) {
        withoutPatching_1.PATCHING.set(editor, true);
        previousChildren = editor.children;
        // This will cancel the throttle when the user is not producing anything for a short time
        const cancelThrottle = lodash_1.debounce(() => {
            change$.next({ type: 'throttle', throttle: false });
            isThrottling = false;
        }, THROTTLE_EDITOR_MS);
        // Inspect incoming patches and adjust editor selection accordingly.
        if (incomingPatche$) {
            incomingPatche$.subscribe((patch) => {
                previousChildren = editor.children;
                debug('Handling incoming patch', patch.type);
                if (isThrottling) {
                    withoutPatching_1.withoutPatching(editor, () => {
                        if (patchToOperations(editor, patch)) {
                            debug('Applied patch in the throttled state', patch.type);
                        }
                        else {
                            adjustSelection(editor, patch, previousChildren);
                        }
                    });
                }
                else {
                    debug('Adjusting selection for patch', patch.type);
                    adjustSelection(editor, patch, previousChildren);
                }
            });
        }
        const { apply } = editor;
        editor.apply = (operation) => {
            let patches = [];
            // The previous value is needed to figure out the _key of deleted nodes. The editor.children would no
            // longer contain that information if the node is already deleted.
            // debug('setting previous children', operation, editor.children)
            previousChildren = editor.children;
            const editorWasEmpty = values_1.isEqualToEmptyEditor(previousChildren, portableTextFeatures);
            // Apply the operation
            apply(operation);
            if (!withoutPatching_1.isPatching(editor)) {
                debug(`Editor is not producing patch for operation ${operation.type}`, operation);
                return editor;
            }
            if (editorWasEmpty && operation.type !== 'set_selection') {
                patches = [PatchEvent_1.setIfMissing(previousChildren, [])];
            }
            switch (operation.type) {
                case 'insert_text':
                    patches = [...patches, ...insertTextPatch(editor, operation, previousChildren)];
                    break;
                case 'remove_text':
                    patches = [...patches, ...removeTextPatch(editor, operation, previousChildren)];
                    break;
                case 'remove_node':
                    patches = [...patches, ...removeNodePatch(editor, operation, previousChildren)];
                    break;
                case 'split_node':
                    patches = [...patches, ...splitNodePatch(editor, operation, previousChildren)];
                    break;
                case 'insert_node':
                    patches = [...patches, ...insertNodePatch(editor, operation, previousChildren)];
                    break;
                case 'set_node':
                    patches = [...patches, ...setNodePatch(editor, operation, previousChildren)];
                    break;
                case 'merge_node':
                    patches = [...patches, ...mergeNodePatch(editor, operation, previousChildren)];
                    break;
                case 'move_node':
                    patches = [...patches, ...moveNodePatch(editor, operation, previousChildren)];
                    break;
                case 'set_selection':
                default:
                // Do nothing
            }
            // Unset the value if editor has become empty
            if (values_1.isEqualToEmptyEditor(editor.children, portableTextFeatures) &&
                operation.type !== 'set_selection') {
                patches.push(PatchEvent_2.unset([]));
                change$.next({
                    type: 'unset',
                    previousValue: values_1.fromSlateValue(previousChildren, portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor))
                });
            }
            // // TODO: extract this to a test
            // if (debug && !isEqualToEmptyEditor(editor.children, portableTextFeatures)) {
            //   const appliedValue = applyAll(
            //     fromSlateValue(previousChildren, portableTextFeatures.types.block.name),
            //     patches
            //   )
            //   if (
            //     !isEqual(
            //       appliedValue,
            //       fromSlateValue(editor.children, portableTextFeatures.types.block.name)
            //     )
            //   ) {
            //     debug(
            //       'toSlateValue',
            //       JSON.stringify(
            //         toSlateValue(appliedValue, portableTextFeatures.types.block.name),
            //         null,
            //         2
            //       )
            //     )
            //     debug('operation', JSON.stringify(operation, null, 2))
            //     debug('beforeValue', JSON.stringify(previousChildren, null, 2))
            //     debug('afterValue', JSON.stringify(editor.children, null, 2))
            //     debug('appliedValue', JSON.stringify(appliedValue, null, 2))
            //     debug('patches', JSON.stringify(patches, null, 2))
            //     debugger
            //   }
            // }
            if (patches.length > 0) {
                // Signal throttling
                change$.next({ type: 'throttle', throttle: true });
                isThrottling = true;
                // Emit all patches immediately
                patches.map(patch => {
                    change$.next({
                        type: 'patch',
                        patch
                    });
                });
                // Emit mutation after user is done typing (we show only local state as that happens)
                change$.next({
                    type: 'mutation',
                    patches: patches
                });
                cancelThrottle();
            }
        };
        return editor;
    };
}
exports.createWithPatches = createWithPatches;
function adjustSelection(editor, patch, previousChildren) {
    let selection = editor.selection;
    if (selection === null) {
        debug('No selection, not adjusting selection');
        return;
    }
    // Text patches on same line
    if (patch.type === 'diffMatchPatch') {
        const [block, blockIndex] = values_1.findBlockAndIndexFromPath(patch.path[0], editor.children);
        if (!block) {
            return;
        }
        const [child, childIndex] = values_1.findChildAndIndexFromPath(patch.path[2], block);
        if (!child) {
            return;
        }
        const onSameBlock = selection.focus.path[0] === blockIndex && selection.focus.path[1] === childIndex;
        if (onSameBlock) {
            const parsed = dmp.patch_fromText(patch.value)[0];
            if (parsed) {
                let testString = '';
                for (const diff of parsed.diffs) {
                    if (diff[0] === 0) {
                        testString += diff[1];
                    }
                    else {
                        break;
                    }
                }
                // This thing is exotic but actually works!
                const isBeforeUserSelection = parsed.start1 + testString.length <= selection.focus.offset &&
                    parsed.start1 + testString.length <= selection.anchor.offset;
                const distance = parsed.length2 - parsed.length1;
                if (isBeforeUserSelection) {
                    debug('Adjusting selection for diffMatchPatch on same line');
                    // debug(
                    //   `Adjusting selection for diffMatchPatch on same line ${JSON.stringify({
                    //     parsed,
                    //     distance,
                    //     isBeforeUserSelection,
                    //     isRemove: parsed.diffs.some(diff => diff[0] === -1),
                    //     testString
                    //   })}`
                    // )
                    const newSelection = Object.assign({}, selection);
                    newSelection.focus = Object.assign({}, selection.focus);
                    newSelection.anchor = Object.assign({}, selection.anchor);
                    newSelection.anchor.offset = newSelection.anchor.offset + distance;
                    newSelection.focus.offset = newSelection.focus.offset + distance;
                    slate_1.Transforms.select(editor, newSelection);
                }
                // TODO: account for intersecting selections!
            }
        }
    }
    // Unset patches on children within a block
    if (patch.type === 'unset' && patch.path.length === 3) {
        const [block, blockIndex] = values_1.findBlockAndIndexFromPath(patch.path[0], previousChildren);
        if (!block) {
            debug('No block found trying to adjust for unset child');
            return;
        }
        if (selection.focus.path[0] === blockIndex) {
            const [, childIndex] = values_1.findChildAndIndexFromPath(patch.path[2], block);
            const prevIndexOrLastIndex = childIndex === -1 || block.children.length === 1 ? block.children.length - 1 : childIndex;
            const prevText = block.children[prevIndexOrLastIndex].text;
            const newSelection = Object.assign({}, selection);
            if (slate_1.Path.endsAt(selection.anchor.path, [blockIndex, prevIndexOrLastIndex])) {
                newSelection.anchor = Object.assign({}, selection.anchor);
                newSelection.anchor.path = newSelection.anchor.path = [
                    newSelection.anchor.path[0],
                    Math.max(0, prevIndexOrLastIndex - 1)
                ];
                const textBefore = ((block.children[prevIndexOrLastIndex - 1] &&
                    block.children[prevIndexOrLastIndex - 1].text) ||
                    '');
                newSelection.anchor.offset = textBefore.length;
            }
            if (slate_1.Path.endsAt(selection.focus.path, [blockIndex, prevIndexOrLastIndex])) {
                newSelection.focus = Object.assign({}, selection.focus);
                newSelection.focus.path = [
                    newSelection.focus.path[0],
                    Math.max(0, prevIndexOrLastIndex - 1)
                ];
                const textBefore = ((block.children[prevIndexOrLastIndex - 1] &&
                    block.children[Math.max(0, prevIndexOrLastIndex - 1)].text) ||
                    '');
                newSelection.focus.offset = textBefore.length + prevText.length;
            }
            if (slate_1.Path.isAfter(selection.anchor.path, [blockIndex, prevIndexOrLastIndex])) {
                newSelection.anchor = Object.assign({}, selection.anchor);
                newSelection.anchor.path = newSelection.anchor.path = [
                    newSelection.anchor.path[0],
                    prevIndexOrLastIndex
                ];
                newSelection.anchor.offset = selection.anchor.offset + prevText.length;
            }
            if (slate_1.Path.isAfter(selection.focus.path, [blockIndex, prevIndexOrLastIndex])) {
                newSelection.focus = Object.assign({}, selection.anchor);
                newSelection.focus.path = newSelection.anchor.path = [
                    newSelection.anchor.path[0],
                    prevIndexOrLastIndex
                ];
                newSelection.anchor.offset = selection.anchor.offset + prevText.length;
            }
            if (!lodash_1.isEqual(newSelection, selection)) {
                debug('adjusting selection for unset block child', newSelection);
                slate_1.Transforms.select(editor, newSelection);
            }
        }
    }
    // Unset patches on block level
    if (patch.type === 'unset' && patch.path.length === 1) {
        let [block, blockIndex] = values_1.findBlockAndIndexFromPath(patch.path[0], previousChildren);
        if (!block || typeof blockIndex === 'undefined') {
            debug('no block found in editor trying to adjust selection for unset block');
            // Naively try to adjust as the block above us have been removed.
            blockIndex = Math.max(0, selection.focus.path[0] - 1);
        }
        const newSelection = Object.assign({}, selection);
        if (slate_1.Path.isAfter(selection.anchor.path, [blockIndex])) {
            newSelection.anchor = Object.assign({}, selection.anchor);
            newSelection.anchor.path = newSelection.anchor.path = [
                Math.max(0, newSelection.anchor.path[0] - 1),
                ...newSelection.anchor.path.slice(1)
            ];
        }
        if (slate_1.Path.isAfter(selection.focus.path, [blockIndex])) {
            newSelection.focus = Object.assign({}, selection.focus);
            newSelection.focus.path = newSelection.focus.path = [
                Math.max(0, newSelection.focus.path[0] - 1),
                ...newSelection.focus.path.slice(1)
            ];
        }
        if (!lodash_1.isEqual(newSelection, selection)) {
            debug('adjusting selection for unset block');
            slate_1.Transforms.select(editor, newSelection);
        }
    }
    // Insert patches on block level
    if (patch.type === 'insert' && patch.path.length === 1) {
        const [block, blockIndex] = values_1.findBlockAndIndexFromPath(patch.path[0], editor.children);
        if (!block || typeof blockIndex === 'undefined') {
            return;
        }
        const newSelection = Object.assign({}, selection);
        if (slate_1.Path.isAfter(selection.anchor.path, [blockIndex])) {
            newSelection.anchor = Object.assign({}, selection.anchor);
            newSelection.anchor.path = newSelection.anchor.path = [
                newSelection.anchor.path[0] + patch.items.length,
                ...newSelection.anchor.path.slice(1)
            ];
        }
        if (slate_1.Path.isAfter(selection.focus.path, [blockIndex])) {
            newSelection.focus = Object.assign({}, selection.focus);
            newSelection.focus.path = newSelection.focus.path = [
                newSelection.focus.path[0] + patch.items.length,
                ...newSelection.focus.path.slice(1)
            ];
        }
        if (!lodash_1.isEqual(newSelection, selection)) {
            debug('adjusting selection for insert block');
            slate_1.Transforms.select(editor, newSelection);
        }
    }
    // Insert patches on block children level
    if (patch.type === 'insert' && patch.path.length === 3) {
        const [block, blockIndex] = values_1.findBlockAndIndexFromPath(patch.path[0], editor.children);
        if (!block || typeof blockIndex === 'undefined') {
            return;
        }
        const [child, childIndex] = values_1.findChildAndIndexFromPath(patch.path[2], block);
        if (!child) {
            return;
        }
        if (selection.focus.path[0] === blockIndex && selection.focus.path[1] === childIndex) {
            const nextIndex = childIndex + patch.items.length;
            const blockChildren = editor.children[blockIndex].children;
            const nextBlock = editor.children[blockIndex + 1];
            const isSplitOperation = !blockChildren[nextIndex] &&
                slate_1.Editor.isBlock(editor, nextBlock) &&
                nextBlock.children &&
                nextBlock.children[0] &&
                typeof nextBlock.children[0]._key === 'string' &&
                lodash_1.isEqual(nextBlock.children[0]._key, patch.items[0]['_key']);
            const [node] = slate_1.Editor.node(editor, selection);
            const nodeText = node.text;
            if (!nodeText) {
                return;
            }
            if (selection.focus.offset >= nodeText.length) {
                if (!isSplitOperation) {
                    const newSelection = Object.assign({}, selection);
                    newSelection.focus = Object.assign({}, selection.focus);
                    newSelection.anchor = Object.assign({}, selection.anchor);
                    newSelection.anchor.path = slate_1.Path.next(newSelection.anchor.path);
                    newSelection.anchor.offset = nodeText.length - newSelection.anchor.offset;
                    newSelection.focus.path = slate_1.Path.next(newSelection.focus.path);
                    newSelection.focus.offset = nodeText.length - newSelection.focus.offset;
                    slate_1.Transforms.select(editor, newSelection);
                }
                else if (selection.focus.offset >= nodeText.length) {
                    debug('adjusting selection for split node');
                    const newSelection = Object.assign({}, selection);
                    newSelection.focus = Object.assign({}, selection.focus);
                    newSelection.anchor = Object.assign({}, selection.anchor);
                    newSelection.anchor.path = [blockIndex + 1, 0];
                    newSelection.anchor.offset = selection.anchor.offset - nodeText.length || 0;
                    newSelection.focus.path = [blockIndex + 1, 0];
                    newSelection.focus.offset = selection.focus.offset - nodeText.length || 0;
                    slate_1.Transforms.select(editor, newSelection);
                }
            }
        }
    }
    if (editor.selection && editor.selection !== selection) {
        return editor.selection;
    }
}
//# sourceMappingURL=createWithPatches.js.map