"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setFragmentData = exports.hasEditableTarget = void 0;
const slate_1 = require("slate");
const slate_react_1 = require("@sanity/slate-react");
const values_1 = require("../utils/values");
const weakMaps_1 = require("./weakMaps");
const isDOMText = (value) => {
    return isDOMNode(value) && value.nodeType === 3;
};
const isDOMNode = (value) => {
    return value instanceof Node;
};
/**
 * Check if the target is editable and in the editor.
 */
exports.hasEditableTarget = (editor, target) => {
    return isDOMNode(target) && slate_react_1.ReactEditor.hasDOMNode(editor, target, { editable: true });
};
/**
 * Set the currently selected Portable Text fragment to the clipboard.
 */
exports.setFragmentData = (dataTransfer, editor, portableTextFeatures) => {
    const { selection } = editor;
    if (!selection) {
        return;
    }
    const [start, end] = slate_1.Range.edges(selection);
    const startVoid = slate_1.Editor.void(editor, { at: start.path });
    const endVoid = slate_1.Editor.void(editor, { at: end.path });
    if (slate_1.Range.isCollapsed(selection) && !startVoid) {
        return;
    }
    // Create a fake selection so that we can add a Base64-encoded copy of the
    // fragment to the HTML, to decode on future pastes.
    const domRange = slate_react_1.ReactEditor.toDOMRange(editor, selection);
    let contents = domRange.cloneContents();
    let attach = contents.childNodes[0];
    // Make sure attach is non-empty, since empty nodes will not get copied.
    contents.childNodes.forEach(node => {
        if (node.textContent && node.textContent.trim() !== '') {
            attach = node;
        }
    });
    // COMPAT: If the end node is a void node, we need to move the end of the
    // range from the void node's spacer span, to the end of the void node's
    // content, since the spacer is before void's content in the DOM.
    if (endVoid) {
        const [voidNode] = endVoid;
        const r = domRange.cloneRange();
        const domNode = slate_react_1.ReactEditor.toDOMNode(editor, voidNode);
        r.setEndAfter(domNode);
        contents = r.cloneContents();
    }
    // COMPAT: If the start node is a void node, we need to attach the encoded
    // fragment to the void node's content node instead of the spacer, because
    // attaching it to empty `<div>/<span>` nodes will end up having it erased by
    // most browsers. (2018/04/27)
    if (startVoid) {
        attach = contents.querySelector('[data-slate-spacer]');
    }
    // Remove any zero-width space spans from the cloned DOM so that they don't
    // show up elsewhere when pasted.
    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {
        const isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
        zw.textContent = isNewline ? '\n' : '';
    });
    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up
    // in the HTML, and can be used for intra-Slate pasting. If it's a text
    // node, wrap it in a `<span>` so we have something to set an attribute on.
    if (isDOMText(attach)) {
        const span = document.createElement('span');
        // COMPAT: In Chrome and Safari, if we don't add the `white-space` style
        // then leading and trailing spaces will be ignored. (2017/09/21)
        span.style.whiteSpace = 'pre';
        span.appendChild(attach);
        contents.appendChild(span);
        attach = span;
    }
    const fragment = values_1.fromSlateValue(slate_1.Node.fragment(editor, selection), portableTextFeatures.types.block.name, weakMaps_1.KEY_TO_VALUE_ELEMENT.get(editor));
    dataTransfer.setData('application/x-portable-text', JSON.stringify(fragment));
};
//# sourceMappingURL=copyPaste.js.map